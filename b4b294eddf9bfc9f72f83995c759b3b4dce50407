{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7a72d40e_0d384acb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-02-28T00:26:45Z",
      "side": 1,
      "message": "Sorry, can you explain what this flag is supposed to do? I don\u0027t really understand it from the design doc linked in the bug. Isn\u0027t the decision you make there entirely static (e.g. based on crosid information)? And even if it must be in runtime storage, why can\u0027t you just put it in a file on disk somewhere?\n\nAlso, crossystem options that are solely used by kernel/userland and don\u0027t have anything to do with firmware control at all should usually go into the kern_nv field (see block_devmode and tpm_attack). But before that there should be a good reason why they need to be in nvdata at all.",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec979203_05f73893",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1104704
      },
      "writtenOn": "2023-02-28T18:05:31Z",
      "side": 1,
      "message": "We need to know if the device is a chromebook X very early in the boot process (the splash screen is different on chromebook X, in init/upstart/boot-splash.conf), so we need it before we mount the stateful partition.\n\nI have debated using kern_nv. My concern is if chromebook X features percolate down to the firmware in the future (early splash screen, different recovery screen), we would be ready.",
      "parentUuid": "7a72d40e_0d384acb",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "130d5d9c_1f9d07f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-03-01T02:49:09Z",
      "side": 1,
      "message": "Well... I mean, I get your point but I feel like using vboot nvdata isn\u0027t a better solution in that case, it\u0027s just one that\u0027s bad in a less obvious way. After all, the reason _why_ we\u0027re putting up the splash screen before we mount the stateful partition is because we consider boot time to splash a critical metric (although we don\u0027t have a regression test for it, but that\u0027s a different issue). We don\u0027t want the boot splash to wait on the stateful being mounted, but if you depend it on a vboot nvdata flag then it needs to wait until vboot nvdata is read instead. Reading 4-16K (depending on the platform) from flash is not free -- in fact, it might be longer than mounting that partition would take. We used to pay very close attention to where the first access to nvdata happens in the startup path because of that very problem, not sure if that\u0027s still the case (that lack of regression testing certainly isn\u0027t helping there), but that\u0027s what we should aim for.\n\nSo... I don\u0027t know... is this really a thing that we _want_ here? Do we want to regress on time-to-display just so that we can print \"Premium\" on the splash screen? That\u0027s not really what I would expect from a premium device as a user.\n\nI also still haven\u0027t understood why this determination must be stored in volatile state? I don\u0027t really see any explanation in the design doc for that. It just has that big flow chart that says \"tier attribute in cros_config\" may be \"low/high\" or \"dynamic\", but it doesn\u0027t say why the latter case needs to exist. Isn\u0027t this all supposed to be just tied to SKUs?\n\nAlso, bear in mind that vboot nvdata may get lost in certain scenarios (e.g. dead battery), and should generally not be considered trusted (e.g. can be changed via SPI programmers, CCD, temporary root exploit, etc.).",
      "parentUuid": "ec979203_05f73893",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2110b7a_b8f8a627",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1104704
      },
      "writtenOn": "2023-03-02T21:01:51Z",
      "side": 1,
      "message": "Normally, tier attribute is in cros_config (or is easily discoverable). \"dynamic\" is for machines which have already shipped (aka legacy support) and where we need to decide of their tier based on their internal (RAM size, camera defintion, display property...). \n\ncrossystem is already used concurrently in chromeos_startup (need to know if we are in dev mode). Would it make sense to cache the result?\n\n[I can also investigate to send a message to frecon splash job when encstateful is mounted and not need to code at all.]",
      "parentUuid": "130d5d9c_1f9d07f1",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c104a88_e2f657de",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1150560
      },
      "writtenOn": "2023-03-02T22:47:58Z",
      "side": 1,
      "message": "before frecon runs we already check dev mode flag using crossystem, so adding more crossystem variables will not affect anything.",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "406b56c1_b7b0b690",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-03-03T00:29:24Z",
      "side": 1,
      "message": "Sorry, I still don\u0027t really understand why this needs to be in nvdata. Aren\u0027t all those factors (RAM size, USB device descriptors, EDID) things you can cheaply query from sysfs even before the stateful partition is mounted? Why not just make that determination on boot for those devices (e.g. in a board-specific shell script or something, especially if this is just a temporary fallback solution for a handful of legacy devices) rather than try to store it persistently somewhere?\n\nNot all crossystem invocations read nvdata. The `cros_debug?1` in chromeos_startup doesn\u0027t. (Also, like I said, regression testing for this isn\u0027t great atm so I can\u0027t 100% guarantee you that this hasn\u0027t been violated anywhere, but if it has we should fix that rather than further entrench the problem.)",
      "parentUuid": "a2110b7a_b8f8a627",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a3b7dd1_9e64f8b4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-03-03T00:29:24Z",
      "side": 1,
      "message": "Not every item you can query via crossystem is an nvdata flag. If you\u0027re talking about `cros_debug?1` or `mainfw_act?developer`, those are implemented differently and do not require flash reads.",
      "parentUuid": "0c104a88_e2f657de",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca119d4d_c45f9052",
        "filename": "host/lib/crossystem.c",
        "patchSetId": 1
      },
      "lineNbr": 579,
      "author": {
        "id": 1104704
      },
      "writtenOn": "2023-02-28T18:05:31Z",
      "side": 1,
      "message": "cut and paste error.",
      "revId": "b4b294eddf9bfc9f72f83995c759b3b4dce50407",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}