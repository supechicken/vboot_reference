{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "10c33681_288137f7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1481202
      },
      "writtenOn": "2022-06-28T16:30:21Z",
      "side": 1,
      "message": "Hi, this is a proposed entry point for the purpose described in b/237093169. We had discussed this in a gdoc some time ago, but hadn\u0027t had a chance to follow up on it until now. I\u0027m very open to any and all thoughts on whether this is a reasonable approach!",
      "revId": "7e7027f53205e0e14bf8219242790f8540296640",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17f81f8b_c4746383",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-06-30T01:35:42Z",
      "side": 1,
      "message": "+Yu-Ping to help review and brainstorm design\n\nGenerally I think the code looks good for what you\u0027re trying to do. (The function name is a bit of a mouthful... maybe vb2api_inject_kernel_subkey() or something like that?)\n\nI\u0027m a bit worried about what other kinds of state our code might expect that you haven\u0027t set up here, and how that could affect things. For example, LoadKernel() does check ctx-\u003eboot_mode in various places, and you\u0027d be running around with BOOT_MODE_UNDEFINED here (which happens to not match any of the things it tests for but is probably still not a good idea). It also accesses nvdata and secdata which you wouldn\u0027t have had initialized here... shouldn\u0027t that be generating an abort for you? Or are you calling vb2_nv_init() and vb2_secdata_..._init() manually before calling this (those are not vb2api_ functions so they\u0027re not really meant for outside callers)?\n\nI think this probably needs to become a little bigger and initialize all those parts of the context and shared data to valid values for your use case. And then we\u0027ll need to come up with a good way to not accidentally break it in the future (lots of unit tests, probably).",
      "revId": "7e7027f53205e0e14bf8219242790f8540296640",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c7cadf4_593c4c86",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1481202
      },
      "writtenOn": "2022-06-30T14:34:30Z",
      "side": 1,
      "message": "Thanks for the review, and agreed the current name is a bit long.\n\nRegarding initialization of other state, I\u0027m not currently calling vb2_nv_init or vb2_secdata*init. I\u0027m only calling vb2api_init, this new function, and LoadKernel, and it succeeds. (The changes I made in tests/verify_kernel.c validate this; the tests still pass.) I\u0027m not sure why it works, maybe some of the other initialization is getting called implicitly by LoadKernel? At any rate, I\u0027ll update the CL to add more explicit initialization.",
      "parentUuid": "17f81f8b_c4746383",
      "revId": "7e7027f53205e0e14bf8219242790f8540296640",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "484a6dfc_ab943dcc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-07-01T01:12:32Z",
      "side": 1,
      "message": "Yeah, upon closer inspection it looks like all the nvdata and secdata accesses just happen to be guarded by checks you wouldn\u0027t pass (e.g. boot_mode \u003d\u003d DEVELOPER). Maybe then it\u0027s better to not initialize this after all (rather than \"initializing\" it with fake data)? That way we would at least notice quickly if the code is trying to depend on something that\u0027s not available in your case. Should have really good unit test coverage for your case then, though.\n\nWhat\u0027s your requirement for rollback protection and things like developer mode... do you need that at all? You should definitely be initializing the rollback version fields in vb2_shared_data, even if just to zero... because the code is using those. For boot_mode I\u0027m still not sure if it would make more sense to create a completely separate boot mode value for your case or reuse the most appropriate existing one.",
      "parentUuid": "8c7cadf4_593c4c86",
      "revId": "7e7027f53205e0e14bf8219242790f8540296640",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a7df886_f7422b92",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1481202
      },
      "writtenOn": "2022-07-07T15:30:23Z",
      "side": 1,
      "message": "\u003e What\u0027s your requirement for rollback protection and things like developer mode... do you need that at all?\n\nEventually I think yes, but perhaps not needed for an initial MVP. Developer mode would just be setting `ctx-\u003eflags \u003d VB2_CONTEXT_DEVELOPER_MODE` when appropriate?\n\n\u003e You should definitely be initializing the rollback version fields in vb2_shared_data, even if just to zero... because the code is using those.\n\nLooks like `vb2api_init` memsets the whole vb2_shared_data to zero, so maybe not necessary to do anything else there?\n\nI\u0027d be interested also to hear more about how you think tests for all this should look. The verify_kernel test run by load_kernel_tests.sh is a nice test of the happy path, but would be good to cover error cases as well. I\u0027m not too clear on the best way to do that though; load_kernel_tests.sh is kind of heavy weight in that it\u0027s generating a real disk to test against. Do you think that\u0027s the right approach to follow for adding more tests, or should I be looking to mock out internals of LoadKernel so that smaller unit tests can avoid needing a real disk? Or some other approach I\u0027m not thinking of?",
      "parentUuid": "484a6dfc_ab943dcc",
      "revId": "7e7027f53205e0e14bf8219242790f8540296640",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "adcbdaf5_59818688",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-07-29T01:57:25Z",
      "side": 1,
      "message": "\u003e Eventually I think yes, but perhaps not needed for an initial MVP. Developer mode would just be setting  ctx-\u003eflags \u003d VB2_CONTEXT_DEVELOPER_MODE  when appropriate?\n\nNo, it\u0027s more complicated than that. There\u0027s some redundancy between the `ctx-\u003eboot_mode` value and context flags here (some of it necessary -- e.g. it\u0027s possible for a Chromebook to generally be in developer mode but currently doing a recovery or diagnostics boot -- and some of it old technical debt because boot_mode was introduced somewhat recently). We need to be careful not to get these redundant bits out of sync in a way that the code wasn\u0027t designed for. It\u0027s probably best if you just set `ctx-\u003eboot_mode` to `VB2_BOOT_MODE_NORMAL` for now.\n\nI\u0027m admittedly a bit worried that this will be hard to get right and even harder to keep right across future changes (this sounded a bit easier when I first suggested it on that doc and didn\u0027t quite think all the details through... sorry). vboot expects the whole context and shared data structures to be valid with invariants that aren\u0027t obviously documented and the only \"official\" way we currently have of getting them into that state is to run through the firmware part first. For example, we have a thing called \"GBB flags\" that can be set in flash to modify behavior all over the place and we regularly add more of them. If we need to check one of them we call vb2api_get_gbb_flags(), which reads them from a workbuffer location pointed to by `sd-\u003egbb_offset` that is initialized very early in the firmware flow. There are no further checks, so if this was called on your stub workbuffer where `sd-\u003egbb_offset` is 0, it would just return some random value. I don\u0027t think anything in LoadKernel() is currently reading GBB flags but that\u0027s no guarantee that this wouldn\u0027t be added in the future.\n\nSo I think we carefully need to go through all vb2_context and vb2_shared_data fields, and either explicitly initialize them to something that would be valid for a normal firmware boot, or make sure that everything using it checks and fails fast for the stub value. For nvdata and secdata we already have those checks (based off VB2_SD_STATUS_NV_INIT and VB2_SD_STATUS_SECDATA_xxx_INIT) so those should be fine. For GBB we could add something similar (just check if `sd-\u003egbb_offset` is 0 in vb2_get_gbb() and vb2ex_abort() in that case).\n\n\u003e Looks like  vb2api_init  memsets the whole vb2_shared_data to zero, so maybe not necessary to do anything else there?\n\nI would suggest to initialize all values explicitly even if there was a memset(), just to make it clear that the initialization was intentional and someone thought it through for that particular field (since like with the example above, zero-initialization isn\u0027t necessarily always a safe state).\n\nFor tests, I think verify_kernel is fine as an integration test and the rest should be covered by unit tests -- i.e. just something that calls your function and then calls LoadKernel() and makes sure it doesn\u0027t abort (and succeeds/fails based on what would be correct for the stubbed out disks). You can follow a similar pattern to tests/vb2_load_kernel_tests.c (but without mocking out the GBB part, probably).",
      "parentUuid": "1a7df886_f7422b92",
      "revId": "7e7027f53205e0e14bf8219242790f8540296640",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}