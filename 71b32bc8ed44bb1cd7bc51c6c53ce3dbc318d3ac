{
  "comments": [
    {
      "key": {
        "uuid": "6685aef8_c58e89ce",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 14
      },
      "lineNbr": 224,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "I still don\u0027t think these offsets need to be stored in shared data, they\u0027re only used once.",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5895ca30_8f110145",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 14
      },
      "lineNbr": 224,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6685aef8_c58e89ce",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24d472f9_7b7cb166",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "I think it would be good to move this one into a shared file (e.g. lib20/misc.c or packed_key.c) and also use it in vb2_load_fw_keyblock()). I would suggest an API of\n\n // Loads key data onto the provided workbuf state, figuring out the right\n // size and only loading as much as necessary. \n vb2_read_gbb_key(ctx, offset, size, \u0026wb)\n\nThen you don\u0027t really malloc anything anymore, the functions using root and recovery key can just load, use and discard the key directly on the workbuf. All this is probably too much for one CL, but we should try to move in that direction (i.e. don\u0027t persist anything on the workbuf permanently and just always memcpy() to malloc() for now until we can get rid of that too).",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f6770c8_f745c737",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Yeah, region-init.c seems like a bizarre place to put all of this in the first place.\n\nI\u0027ll change the function signature as you suggested.  Although I am still thinking that vb2_load_fw_keyblock could call VbGbbReadRootKey directly, since that\u0027s the key it needs?  In that case, not sure if we want to continue passing the vb2_workbuf all the way down, or just pass the VbPublicKey pointer back, and assume the caller knows not to mess with the workbuf while using the VbPublicKey data.",
      "parentUuid": "24d472f9_7b7cb166",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fc5a5b1_e723a527",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-14T23:19:43Z",
      "side": 1,
      "message": "Actually, sorry, after reading this again I think we in fact *have* to pass the workbuf through already in this patch (which will expand its footprint even more, unfortunately). We have to be really careful when using the workbuffer and I think this version may already do something dangerous. vb2_workbuf_from_ctx() is not a function we can just randomly call anywhere without carefully looking at the call stack.\n\nIf you look at VbVerifyMemoryBootImage(), it calls VbGbbReadRecoveryKey() (which will allocate the recovery key on the workbuffer here), and then a couple of lines later it calls vb2_workbuf_from_ctx() to pass a workbuffer into vb2_verify_keyblock() (which uses it for scratch space). We don\u0027t write back the current workbuffer state after reading the recovery key, so that scratch space will in fact use the same bytes and corrupt the key. If you try to boot an image in recovery mode with this patch, I think it should blow up.\n\nBut writing back the workbuffer state wouldn\u0027t help either... it\u0027s just coincidence that VbVerifyMemoryBootImage() calls vb2_workbuf_from_ctx() *after* VbGbbReadRecoveryKey(). It might as well have been written to call that at the top of the function instead. I think we need to institute a policy (in reviews, at least... I don\u0027t think there\u0027s a good way to codify that) that functions may only call vb2_workbuf_from_ctx() if they\u0027re certain that no other function above them in the call stack has been using the work buffer before them. So essentially it should only be called in \"top-level\" API entry points (or things close to that, at least), and never in low-level utility functions that can be called from multiple points (like this one). For those, they need to always take in an explicit work buffer pointer.",
      "parentUuid": "5f6770c8_f745c737",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc5182e5_c9d1eefe",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-16T11:29:29Z",
      "side": 1,
      "message": "I did a bit of thinking about this workbuf issue... I came up with a few ideas.\n\n(1) I think this is the same as what you have written above, except maybe a bit stricter.  *Only* top-level functions may create a local workbuf (using vb2_workbuf_from_ctx).  *Everything* else must accept a vb2_workbuf* argument.  (Alternatively, top-level functions may also accept vb2_workbuf*.  But then the caller of the API has to manually specify ctx-\u003eworkbuf, which is somewhat silly.  Except for the case when an API function may also double as a utility function by vboot itself.)  So essentially, the workbuf stack gets built up through function arguments, and saved on success / thrown out on failure as necessary.\n\n(2) Always use the global vb2_workbuf.  Explicitly pop on failures.  This is starting to look more like a malloc/free scheme.  When errors occur in a function, or when a function no longer needs some space that it allocated, it is always the function\u0027s responsibility to call pop.  This has the advantage of not needing to plumb vb2_workbuf through all of the arguments of vboot functions.  The disadvantage is that we no longer have the elegant workflow of \"throwing away a local vb2_workbuf\".  Not to mention probably changing quite a lot of code.  If we forget to pop something, it\u0027s not the end of the world.  It just takes up some extra space on the stack.  These bugs might be easy to crop up, but at least they wouldn\u0027t cause correctness issues like we are seeing with scheme #1.  Another interesting side-effect of using explicit frees is that we could swap out the backend for real DRAM malloc/free when we reach the kernel verification stage, regardless of whether functions are shared between both firmware and kernel verification stages.  (Well, that may get a little tricky when we import the workbuf from firmware stage.  And also in all of the offset calculation that we use everywhere.  See below.)\n\n(3) Like #2, with an added memory defragmentation function.  Defrag would get rid of empty spaces in the stack (which is done manually in some vboot code currently).  But we would need some intermediary pointer lookup table to keep track of where the offsets are stored, since their locations may change.  Lookups would have to go through this pointer table.  The advantage is that we don\u0027t have to think so much about low-level memory management (which may easily introduce bugs).  The disadvantage is that it is rather complex, and perhaps unnecessary for just a few cases where objects need to be removed/relocated \"within the stack\".\n\nHonestly, #1 and #2 would probably take equal time to implement.  #1 is probably \"easier\" since it doesn\u0027t have to happen all at once, whereas #2 would need a big refactor to add all of the explicit pops.  #3 is probably overkill, especially when our primary goal is getting rid of vboot1 code.",
      "parentUuid": "4fc5a5b1_e723a527",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e6e2638_a75ac69c",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-16T20:12:28Z",
      "side": 1,
      "message": "None of these really seem feasible to me tbh. Like you said you can\u0027t always explicitly pop because we have those instances where we need to move things around. I think we need those to make it fit in some parts of firmware verification. I don\u0027t think we want to do anything that has to manually keep track of any location that might have a pointer into the work buffer either (that would not just be shared data but could also be on the stack). I think the only reasonable way to solve that would be with a real allocator, and maybe that\u0027s an option, but I\u0027m still worried that it wouldn\u0027t fit in quite as little space as the current solution.\n\nI think Randall spent quite a bit of time thinking about this before coming up with this work buffer thing and it\u0027s not easy to do anything better. We just need to stick with it and make sure we\u0027re using it right... which includes only ever initializing it from context at the top level. I don\u0027t think it needs to be strict that *every* function takes a workbuffer (some just don\u0027t need it) or that it\u0027s always exactly the topmost function, but we need to pass it where needed and everywhere we add a new vb2_workbuf_from_ctx() we need to pay extra attention that there\u0027s no other workbuffer use in the same call stack.",
      "parentUuid": "cc5182e5_c9d1eefe",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80354ed7_aa2051f5",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-20T09:58:45Z",
      "side": 1,
      "message": "So I attempted to re-work the GBB-reading functions to take a vb2_workbuf as we discussed.  The tricky part is -- sometimes the caller wants to keep the result on the stack, sometimes it does not.  But the caller doesn\u0027t necessarily even know how big was the data added.  So I ended up needing to add another argument called \"save_on_wb\" to decide whether to commit the new workbuf back to the caller.\n\nI am still not convinced this is a good design -- it feels very clunky and seems easy to make mistakes.",
      "parentUuid": "3e6e2638_a75ac69c",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c658a2cf_718203da",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-20T23:36:22Z",
      "side": 1,
      "message": "Sorry, I still don\u0027t understand why you did it that way now. Your save_on_wb should always be 1. If the caller wants to be able to discard the results later, it can create its own copy of the workbuf structure and then discard it at a time of its choosing. We should never at any point be in a situation where data on the workbuf is still used but there is no workbuf structure containing the workbuf state with that data allocated anymore.\n\nI think our workbuf ground rules should essentially be:\n\n1. Only one function in any possible call stack may call vb2_workbuf_from_ctx() (which yields a valid workbuf struct).\n2. workbuf structs may be passed around by reference to other functions.\n3. Any function that somehow got a valid workbuf struct may call vb2_workbuf_alloc() on it.\n4. Any function may call vb2_workbuf_free() iff the corresponding vb2_workbuf_alloc() call was in the same function, it didn\u0027t do any other vb2_workbuf_alloc() calls since that haven\u0027t been freed yet and the workbuf struct was not passed to any other function in between.\n5. Any function may create a struct copy of a valid workbuf struct. That function determines the lifetime of that struct copy (ideally with an explicit { C block } ). Within the lifetime of the copy, the function must not do anything with the original workbuf struct and must not pass the original to any other function (but it may do allocations on and pass around the copy instead). At the end of the copy\u0027s lifetime, the function must cease using any data allocated on the copy (including data allocated in and return from functions called by it, passing the copy). Afterwards it goes back to using/passing the original workbuf struct.\n6. As a special exception to the above, at the moment a workbuf copy\u0027s lifetime ends (and only there) a function may vb2_workbuf_alloc() a single object on the original workbuf and then memmove() that object from the workbuf copy into the new allocation on the original.\n\n(Maybe we should put a list like that as a comment somewhere into 2common.h?)\n\nYour new functions would violate this when save_on_wb is 0 because you expect the caller to still use data allocated on the workbuf copy object that has already gone out of scope. I think we should forbid uses like that because it\u0027s too hard to keep track of data lifetime (in the same way you wouldn\u0027t keep using heap data after a free() even if you know it should still be there until the next time someone calls malloc()). Instead, if a copy is desired the caller should make that copy and it should be very explicit from the code where the lifetime of the copy ends... e.g. maybe we should always write code using workbuf copies like this:\n\n int myfunc(struct vb2_workbuf *wb)\n {\n   struct somestruct s \u003d vb2_workbuf_alloc(\u0026wb, ...);\n   \n   some_other_code(\u0026s);\n   some_func_that_may_alloc(\u0026wb);\n\n   {\n     struct vb2_workbuf tmp_wb \u003d *wb;\n     vb2_packed_key *key;\n\n     vb2_gbb_read_recovery_key(\u0026tmp_wb, \u0026key);\n     \n     copy_key_components_into_struct(\u0026key, \u0026s)\n   }\n\n   stuff_can_use_original_wb_again(\u0026wb);\n }\n\nThat way the C scope helps you with most aspects of keeping track of the temporary allocations. The only thing left to manually remember is that you mustn\u0027t use \u0027wb\u0027 anywhere within the block after the initial struct copy.",
      "parentUuid": "80354ed7_aa2051f5",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "156e4b2a_167678cf",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-23T10:58:57Z",
      "side": 1,
      "message": "Those ground rules seem pretty good for dealing with this madness.\n\nI also realized that we sort of need to make a choice as to whether to put the burden of \"error handling\" on the function caller or callee.\n\n[A] If the burden is on the caller, then the caller must assume that the workbuf sent into the function may be in different states before vs. after the function call.  As such, almost all callers should create a local workbuf to send into the function as you have suggested.  (Except in the case where a failure will cascade down -- then preserving the original state of the caller\u0027s workbuf doesn\u0027t actually matter.)\n\n[B] If the burden is on the callee, then the callee must always leave workbuf in its original state on failure.  This means that when a caller *wants* to keep the result of some function call on the workbuf permanently, it may simply pass the current workbuf without creating a local copy.  In the case that it only needs the value from the workbuf temporarily, it may create a local copy of the workbuf for the function call, and then throw it away after reading the data.\n\nI\u0027m inclined to using [B], which enforces well-designed functions, and simplifies the calling process.",
      "parentUuid": "c658a2cf_718203da",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47c029fc_29998fb2",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 53,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "No need to cache these anywhere, each key is only needed once (in normal mode).",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f805396_b3441da5",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 53,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "47c029fc_29998fb2",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baf91b9e_b82cfb21",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 99,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "Just load it directly into the provided buffer. Not used in any critical path.",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c454632_d7db4917",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 99,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "baf91b9e_b82cfb21",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb3445aa_9c6aa7fd",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 120,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "Can this just be a return?",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82012c38_a80efeb5",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 120,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cb3445aa_9c6aa7fd",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbf9d546_22063165",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 136,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "I don\u0027t think there\u0027s any way this can be NULL? If you want to allow for that possibility, you\u0027ll need to make vb2_get_gbb() explicitly check if the offset is 0 and then return NULL.",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c450ab84_9df54f97",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 136,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Ahh... good point.  Let\u0027s just specify that these functions may only be called after reading in GBB headers.",
      "parentUuid": "fbf9d546_22063165",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab40d30b_23b3c24a",
        "filename": "tests/vb2_misc_tests.c",
        "patchSetId": 14
      },
      "lineNbr": 22,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "You\u0027re not overriding vb2_get_gbb() in this one?",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "350ffccb_d3b8ec81",
        "filename": "tests/vb2_misc_tests.c",
        "patchSetId": 14
      },
      "lineNbr": 22,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Err, I guess I missed this one.  Thanks.",
      "parentUuid": "ab40d30b_23b3c24a",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}