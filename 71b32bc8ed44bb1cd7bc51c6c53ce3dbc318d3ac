{
  "comments": [
    {
      "key": {
        "uuid": "6685aef8_c58e89ce",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 14
      },
      "lineNbr": 224,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "I still don\u0027t think these offsets need to be stored in shared data, they\u0027re only used once.",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5895ca30_8f110145",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 14
      },
      "lineNbr": 224,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6685aef8_c58e89ce",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24d472f9_7b7cb166",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "I think it would be good to move this one into a shared file (e.g. lib20/misc.c or packed_key.c) and also use it in vb2_load_fw_keyblock()). I would suggest an API of\n\n // Loads key data onto the provided workbuf state, figuring out the right\n // size and only loading as much as necessary. \n vb2_read_gbb_key(ctx, offset, size, \u0026wb)\n\nThen you don\u0027t really malloc anything anymore, the functions using root and recovery key can just load, use and discard the key directly on the workbuf. All this is probably too much for one CL, but we should try to move in that direction (i.e. don\u0027t persist anything on the workbuf permanently and just always memcpy() to malloc() for now until we can get rid of that too).",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f6770c8_f745c737",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Yeah, region-init.c seems like a bizarre place to put all of this in the first place.\n\nI\u0027ll change the function signature as you suggested.  Although I am still thinking that vb2_load_fw_keyblock could call VbGbbReadRootKey directly, since that\u0027s the key it needs?  In that case, not sure if we want to continue passing the vb2_workbuf all the way down, or just pass the VbPublicKey pointer back, and assume the caller knows not to mess with the workbuf while using the VbPublicKey data.",
      "parentUuid": "24d472f9_7b7cb166",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fc5a5b1_e723a527",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-14T23:19:43Z",
      "side": 1,
      "message": "Actually, sorry, after reading this again I think we in fact *have* to pass the workbuf through already in this patch (which will expand its footprint even more, unfortunately). We have to be really careful when using the workbuffer and I think this version may already do something dangerous. vb2_workbuf_from_ctx() is not a function we can just randomly call anywhere without carefully looking at the call stack.\n\nIf you look at VbVerifyMemoryBootImage(), it calls VbGbbReadRecoveryKey() (which will allocate the recovery key on the workbuffer here), and then a couple of lines later it calls vb2_workbuf_from_ctx() to pass a workbuffer into vb2_verify_keyblock() (which uses it for scratch space). We don\u0027t write back the current workbuffer state after reading the recovery key, so that scratch space will in fact use the same bytes and corrupt the key. If you try to boot an image in recovery mode with this patch, I think it should blow up.\n\nBut writing back the workbuffer state wouldn\u0027t help either... it\u0027s just coincidence that VbVerifyMemoryBootImage() calls vb2_workbuf_from_ctx() *after* VbGbbReadRecoveryKey(). It might as well have been written to call that at the top of the function instead. I think we need to institute a policy (in reviews, at least... I don\u0027t think there\u0027s a good way to codify that) that functions may only call vb2_workbuf_from_ctx() if they\u0027re certain that no other function above them in the call stack has been using the work buffer before them. So essentially it should only be called in \"top-level\" API entry points (or things close to that, at least), and never in low-level utility functions that can be called from multiple points (like this one). For those, they need to always take in an explicit work buffer pointer.",
      "parentUuid": "5f6770c8_f745c737",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc5182e5_c9d1eefe",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-16T11:29:29Z",
      "side": 1,
      "message": "I did a bit of thinking about this workbuf issue... I came up with a few ideas.\n\n(1) I think this is the same as what you have written above, except maybe a bit stricter.  *Only* top-level functions may create a local workbuf (using vb2_workbuf_from_ctx).  *Everything* else must accept a vb2_workbuf* argument.  (Alternatively, top-level functions may also accept vb2_workbuf*.  But then the caller of the API has to manually specify ctx-\u003eworkbuf, which is somewhat silly.  Except for the case when an API function may also double as a utility function by vboot itself.)  So essentially, the workbuf stack gets built up through function arguments, and saved on success / thrown out on failure as necessary.\n\n(2) Always use the global vb2_workbuf.  Explicitly pop on failures.  This is starting to look more like a malloc/free scheme.  When errors occur in a function, or when a function no longer needs some space that it allocated, it is always the function\u0027s responsibility to call pop.  This has the advantage of not needing to plumb vb2_workbuf through all of the arguments of vboot functions.  The disadvantage is that we no longer have the elegant workflow of \"throwing away a local vb2_workbuf\".  Not to mention probably changing quite a lot of code.  If we forget to pop something, it\u0027s not the end of the world.  It just takes up some extra space on the stack.  These bugs might be easy to crop up, but at least they wouldn\u0027t cause correctness issues like we are seeing with scheme #1.  Another interesting side-effect of using explicit frees is that we could swap out the backend for real DRAM malloc/free when we reach the kernel verification stage, regardless of whether functions are shared between both firmware and kernel verification stages.  (Well, that may get a little tricky when we import the workbuf from firmware stage.  And also in all of the offset calculation that we use everywhere.  See below.)\n\n(3) Like #2, with an added memory defragmentation function.  Defrag would get rid of empty spaces in the stack (which is done manually in some vboot code currently).  But we would need some intermediary pointer lookup table to keep track of where the offsets are stored, since their locations may change.  Lookups would have to go through this pointer table.  The advantage is that we don\u0027t have to think so much about low-level memory management (which may easily introduce bugs).  The disadvantage is that it is rather complex, and perhaps unnecessary for just a few cases where objects need to be removed/relocated \"within the stack\".\n\nHonestly, #1 and #2 would probably take equal time to implement.  #1 is probably \"easier\" since it doesn\u0027t have to happen all at once, whereas #2 would need a big refactor to add all of the explicit pops.  #3 is probably overkill, especially when our primary goal is getting rid of vboot1 code.",
      "parentUuid": "4fc5a5b1_e723a527",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e6e2638_a75ac69c",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 45,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-16T20:12:28Z",
      "side": 1,
      "message": "None of these really seem feasible to me tbh. Like you said you can\u0027t always explicitly pop because we have those instances where we need to move things around. I think we need those to make it fit in some parts of firmware verification. I don\u0027t think we want to do anything that has to manually keep track of any location that might have a pointer into the work buffer either (that would not just be shared data but could also be on the stack). I think the only reasonable way to solve that would be with a real allocator, and maybe that\u0027s an option, but I\u0027m still worried that it wouldn\u0027t fit in quite as little space as the current solution.\n\nI think Randall spent quite a bit of time thinking about this before coming up with this work buffer thing and it\u0027s not easy to do anything better. We just need to stick with it and make sure we\u0027re using it right... which includes only ever initializing it from context at the top level. I don\u0027t think it needs to be strict that *every* function takes a workbuffer (some just don\u0027t need it) or that it\u0027s always exactly the topmost function, but we need to pass it where needed and everywhere we add a new vb2_workbuf_from_ctx() we need to pay extra attention that there\u0027s no other workbuffer use in the same call stack.",
      "parentUuid": "cc5182e5_c9d1eefe",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47c029fc_29998fb2",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 53,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "No need to cache these anywhere, each key is only needed once (in normal mode).",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f805396_b3441da5",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 53,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "47c029fc_29998fb2",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "baf91b9e_b82cfb21",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 99,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "Just load it directly into the provided buffer. Not used in any critical path.",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c454632_d7db4917",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 99,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "baf91b9e_b82cfb21",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb3445aa_9c6aa7fd",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 120,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "Can this just be a return?",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82012c38_a80efeb5",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 120,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cb3445aa_9c6aa7fd",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fbf9d546_22063165",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 136,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "I don\u0027t think there\u0027s any way this can be NULL? If you want to allow for that possibility, you\u0027ll need to make vb2_get_gbb() explicitly check if the offset is 0 and then return NULL.",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c450ab84_9df54f97",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 14
      },
      "lineNbr": 136,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Ahh... good point.  Let\u0027s just specify that these functions may only be called after reading in GBB headers.",
      "parentUuid": "fbf9d546_22063165",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab40d30b_23b3c24a",
        "filename": "tests/vb2_misc_tests.c",
        "patchSetId": 14
      },
      "lineNbr": 22,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-05-10T23:27:20Z",
      "side": 1,
      "message": "You\u0027re not overriding vb2_get_gbb() in this one?",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "350ffccb_d3b8ec81",
        "filename": "tests/vb2_misc_tests.c",
        "patchSetId": 14
      },
      "lineNbr": 22,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-14T09:24:55Z",
      "side": 1,
      "message": "Err, I guess I missed this one.  Thanks.",
      "parentUuid": "ab40d30b_23b3c24a",
      "revId": "71b32bc8ed44bb1cd7bc51c6c53ce3dbc318d3ac",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}