{
  "comments": [
    {
      "key": {
        "uuid": "7fd184e1_72479884",
        "filename": "firmware/2lib/2common.c",
        "patchSetId": 9
      },
      "lineNbr": 17,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2014-05-23T18:29:17Z",
      "side": 1,
      "message": "nit: This should technically be uintptr_t",
      "revId": "ddee9c904713229d2e48c4d6a091dd8678d30269",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff965405_68b46cbf",
        "filename": "firmware/2lib/2sha_utility.c",
        "patchSetId": 9
      },
      "lineNbr": 26,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2014-05-23T18:29:17Z",
      "side": 1,
      "message": "I think defining a second set of algorithm constants that are specially mapped to the other ones and using a custom translation function makes this much harder to understand than it has to be. You only use this function in switch-statements anyway, you could just as well add multiple case-labels per SHA-algorithm and use the original vb2_crypto_algorithm constants (this would also be more consistent with what 2rsa.c does).",
      "revId": "ddee9c904713229d2e48c4d6a091dd8678d30269",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bfa05c5b_bf0873b6",
        "filename": "firmware/2lib/include/2common.h",
        "patchSetId": 9
      },
      "lineNbr": 17,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2014-05-23T18:29:17Z",
      "side": 1,
      "message": "Do we care about non-gcc compatibility? Otherwise it might be better to implement a safe (single-evaluation) max() here just in case it will ever become important.",
      "revId": "ddee9c904713229d2e48c4d6a091dd8678d30269",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f9d5828_7edaed83",
        "filename": "firmware/2lib/include/2common.h",
        "patchSetId": 9
      },
      "lineNbr": 23,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2014-05-23T18:29:17Z",
      "side": 1,
      "message": "Where does printf come from... is the firmware expected to provide it? If so, is there a list of symbols that the firmware needs to provide somewhere?\n\nI\u0027ve also seen a few memcmp/memcpy/memmove/etc. around... I think it might be better to make these explicit vb2ex_printf/vb2ex_memcpy/etc., so that there can be absolutely no confusion about what symbols are expected and how their signatures need to look like.",
      "revId": "ddee9c904713229d2e48c4d6a091dd8678d30269",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bfa05c5b_50803c38",
        "filename": "firmware/2lib/include/2common.h",
        "patchSetId": 9
      },
      "lineNbr": 31,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2014-05-23T18:29:17Z",
      "side": 1,
      "message": "Takes a while to understand how this works. It\u0027s really a kind of stack, and you have to always free space in the reverse order that it was allocated to make it stay consistent. Maybe some more comments here should explain that explicitly (the \"pairing allocs and frees\" below wasn\u0027t clear to me on its own).\n\nYou could also explain somewhere (here or in 2api.h) that the ctx-\u003eworkbuf_used pointer is not written back automatically and needs to be explicitly set if one wants to persist something between calls.",
      "revId": "ddee9c904713229d2e48c4d6a091dd8678d30269",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}