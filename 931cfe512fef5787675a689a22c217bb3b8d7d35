{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0e6ce77e_5840c04b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 3487009
      },
      "writtenOn": "2025-05-05T16:19:07Z",
      "side": 1,
      "message": "Automatically set CQ+1 by AutoRunner. See go/chromeos-cqw:auto-runner-doc for details. \nReport Bugs/Feedback: go/cros-auto-runner-bug. \n",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6505dce1_e58f3d85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-05-06T01:22:41Z",
      "side": 1,
      "message": "Before we review this, can someone remind me if there is even still any reason *why* we\u0027re using EARLY_EC_SYNC on x86? (Apologies if I\u0027ve asked this before and forgotten the answer since.) Originally this option was introduced to help with power envelope edge cases when the EC was booting in RO with dead battery and couldn\u0027t do PD negotiation, where we were worried that the device couldn\u0027t reach depthcharge on 15W. But that problem has since been solved separately with EC-EFS2. So nowadays the EC should always be able to do PD negotiation even when the AP is booting in recovery mode (and besides, I\u0027m not sure if these newer Intel chips could even get to romstage and turn on the eSOL display on 15W?).\n\nSo why are we still doing this EARLY_EC_SYNC thing? If we don\u0027t need it for power, then otherwise it has only drawbacks (e.g. it doesn\u0027t allow us to compress the EC image in CBFS). Why don\u0027t we just turn it off and then we don\u0027t have this problem and don\u0027t need to add new eSOL screens, because the normal depthcharge UI can handle it?",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0e179de_040f88d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 3436255
      },
      "writtenOn": "2025-05-06T03:17:16Z",
      "side": 1,
      "message": "Agreed that EARLY_EC_SYNC has drawbacks and we have moved on to do it from depthcharge. However in some recent nissa devices we are seeing a particular issue with EC switching to RW in depthcharge. Please check b/412210635 description for more details on this. To solve this particular issue, we are forced to move EC sync to coreboot and in turn have to implement eSOL for better UX.",
      "parentUuid": "6505dce1_e58f3d85",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "492c40a9_16939a43",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-05-06T06:25:11Z",
      "side": 1,
      "message": "From b/386920751#comment101, it looks like we enabled `VBOOT_EARLY_EC_SYNC` for Rull (Nissa), just in order for EC RW to complete PD negotiation before showing firmware screen. I didn\u0027t read every comment on the bug, but have we considered adding a short delay or busy loop (waiting for PD negotiation to complete) before showing firmware screen? That delay won\u0027t affect normal boot time anyway.",
      "parentUuid": "d0e179de_040f88d1",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2cd36b73_6f5e9b4b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-05-06T06:53:41Z",
      "side": 1,
      "message": "\u003e From b/386920751#comment101, it looks like we enabled `VBOOT_EARLY_EC_SYNC` for Rull (Nissa), just in order for EC RW to complete PD negotiation before showing firmware screen. I didn\u0027t read every comment on the bug, but have we considered adding a short delay or busy loop (waiting for PD negotiation to complete) before showing firmware screen? That delay won\u0027t affect normal boot time anyway.\n\n\nIn summary, it looks like the ITE EC chip has a limitation where it takes 1 second to settle down when switching from read-only to read-write mode. If we send any commands to get PD mux info during this transition, we get incorrect data. After a month of analysis, we\u0027ve determined that syncing the EC in romstage is the best way to fix this error. We can\u0027t keep 1sec delay before sending any PD mux info cmd.\n\nWe\u0027ve already moved EC sync for rull and equivalent devices, but it can take 4-8 seconds to complete. To ensure users are notified during this time, we\u0027re working on enabling eSOL during EC sync.",
      "parentUuid": "492c40a9_16939a43",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4c17f1a3_96e65db3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-05-13T16:11:10Z",
      "side": 1,
      "message": "Okay, if you\u0027ve decided the solution for Nissa, I have no problem with that.",
      "parentUuid": "2cd36b73_6f5e9b4b",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7eb4de9c_34970611",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-05-14T21:49:47Z",
      "side": 1,
      "message": "Sorry, I\u0027ve tried to read through b/412210635 and b/386920751 but I\u0027m still not sure I understand the underlying problem. Can somebody summarize why it is impossible to fix the bug with depthcharge sync? The EARLY_EC_SYNC path is technical debt that I\u0027d prefer to remove eventually, not further cement as workarounds for various minor issues. There\u0027s a pretty big cost attached to maintaining two entirely different paths for EC sync with each their own quirks. We should try to get away from that unless we have a really hard reason.\n\nAs I understood those bugs, the EC temporarily reports an incorrect mode (role) after the software sync sysjump. But if the situation fixes itself eventually, then shouldn\u0027t depthcharge also eventually notice that fix (and e.g. reenumerate USB devices at that point that it previously lost track of)? Is the problem that depthcharge doesn\u0027t continuously poll that state correctly from the EC?\n\nOr is the problem what I think b/386920751#comment93 is saying, that depthcharge hands off to the OS before the EC has sorted out the situation on its end? But why is that a problem? Wouldn\u0027t the OS re-read this state from the EC eventually? I don\u0027t really understand how some temporary state confusion on the EC leads to a permanent problem on the AP side here.\n\n...also, maybe I have completely forgotten how all this works, but why is the EC even sysjumping in depthcharge in the first place? Wasn\u0027t the whole point of EC-EFS2 that the EC no longer sysjumps in depthcharge (instead, it will have decided to boot from RO or RW before the AP even started, and if AP software sync decides to change that that causes a full system reset)? I fail to understand how with EFS2 anything the AP does during the software sync stage causes the EC to redo PD negotiation in the first place. Or is Nissa not actually using EFS2 for some reason?",
      "parentUuid": "4c17f1a3_96e65db3",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cee052b0_e044d649",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-05-15T02:50:32Z",
      "side": 1,
      "message": "\u003e Sorry, I\u0027ve tried to read through b/412210635 and b/386920751 but I\u0027m still not sure I understand the underlying problem. Can somebody summarize why it is impossible to fix the bug with depthcharge sync? The EARLY_EC_SYNC path is technical debt that I\u0027d prefer to remove eventually, not further cement as workarounds for various minor issues. There\u0027s a pretty big cost attached to maintaining two entirely different paths for EC sync with each their own quirks. We should try to get away from that unless we have a really hard reason.\n\u003e \n\u003e As I understood those bugs, the EC temporarily reports an incorrect mode (role) after the software sync sysjump. But if the situation fixes itself eventually, then shouldn\u0027t depthcharge also eventually notice that fix (and e.g. reenumerate USB devices at that point that it previously lost track of)? Is the problem that depthcharge doesn\u0027t continuously poll that state correctly from the EC?\n\u003e \n\u003e Or is the problem what I think b/386920751#comment93 is saying, that depthcharge hands off to the OS before the EC has sorted out the situation on its end? But why is that a problem? Wouldn\u0027t the OS re-read this state from the EC eventually? I don\u0027t really understand how some temporary state confusion on the EC leads to a permanent problem on the AP side here.\n\u003e \n\u003e ...also, maybe I have completely forgotten how all this works, but why is the EC even sysjumping in depthcharge in the first place? Wasn\u0027t the whole point of EC-EFS2 that the EC no longer sysjumps in depthcharge (instead, it will have decided to boot from RO or RW before the AP even started, and if AP software sync decides to change that that causes a full system reset)? I fail to understand how with EFS2 anything the AP does during the software sync stage causes the EC to redo PD negotiation in the first place. Or is Nissa not actually using EFS2 for some reason?\n\nAdding more details and Pranava is writing the gap analysis doc as this issue is seen on multiple ADL-N devices with the same EC chip.\n\nIn a nutshell, the ITE EC chip has a one-second settling period when transitioning from read-only to read-write mode. If we send commands to obtain PD mux info during this transition, we receive incorrect data. After the AP FW reads this information (e.g., no device is connected to the USB-C port), it sends a PMC IPC to disconnect the USB-C port connection. As a result, the existing USB-C device fails to enumerate, charge, or boot into the OS. Even though a USB-C device is connected, it won\u0027t be detected after booting into the OS due to misconfiguration by the EC and AP during boot. This leads to multiple TAST test failures, including USB-ethernet loss and USB device failure during boot. The user impact is that users will lose their attached USB device on Type-C after the EC switches between RO and RW (EC sync). To recover the device, we need to perform an additional reset.",
      "parentUuid": "7eb4de9c_34970611",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db5cc712_0423bebd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-05-15T02:51:06Z",
      "side": 1,
      "message": "@pranava, I guess you don\u0027t need this CL. can you please abandon this to avoid any further confusion ?",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b4b868f_4ef5eb90",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 2
      },
      "lineNbr": 1264,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-05-13T16:11:10Z",
      "side": 1,
      "message": "Looking at how these 2 functions are called in CB:87575, I don\u0027t think we actually need these 2 functions. The existing vboot API already provides `vb2ex_ec_update_image` as the callback function. In the coreboot implementation of `vb2ex_ec_update_image` you can simply show the SOL screen before doing the actual update. Note that we\u0027re doing the same in depthcharge for showing the firmware sync screen.\n\nIn coreboot I\u0027d write something like:\n\n```\n// src/security/vboot/ec_sync.c\n__weak void mainboard_prepare_ec_update(void) { }\n\nvb2_error_t vb2ex_ec_update_image(...)\n{\n    mainboard_prepare_ec_update();\n    return ec_update_image(select); \n}\n\n// src/soc/intel/alderlake/romstage/romstage.c\nvoid mainboard_prepare_ec_update(void)\n{\n    static bool informed;\n    if (CONFIG(VBOOT_EC_SYNC_ESOL) \u0026\u0026 !informed) {\n        ux_inform_user_of_update_operation(...);\n        informed \u003d true;\n    }\n}\n\nvoid mainboard_romstage_entry(void)\n{\n    ...\n    if (CONFIG(VBOOT_EARLY_EC_SYNC) \u0026\u0026 CONFIG(VBOOT_EC_SYNC_ESOL))\n        vboot_sync_ec();\n}\n```\n\nLet me know if that works for you.",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c293e2d_820ca576",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 2
      },
      "lineNbr": 1264,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-05-13T16:33:06Z",
      "side": 1,
      "message": "\u003e Looking at how these 2 functions are called in CB:87575, I don\u0027t think we actually need these 2 functions. The existing vboot API already provides `vb2ex_ec_update_image` as the callback function. In the coreboot implementation of `vb2ex_ec_update_image` you can simply show the SOL screen before doing the actual update. Note that we\u0027re doing the same in depthcharge for showing the firmware sync screen.\n\u003e \n\u003e In coreboot I\u0027d write something like:\n\u003e \n\u003e ```\n\u003e // src/security/vboot/ec_sync.c\n\u003e __weak void mainboard_prepare_ec_update(void) { }\n\u003e \n\u003e vb2_error_t vb2ex_ec_update_image(...)\n\u003e {\n\u003e     mainboard_prepare_ec_update();\n\u003e     return ec_update_image(select); \n\u003e }\n\u003e \n\u003e // src/soc/intel/alderlake/romstage/romstage.c\n\u003e void mainboard_prepare_ec_update(void)\n\u003e {\n\u003e     static bool informed;\n\u003e     if (CONFIG(VBOOT_EC_SYNC_ESOL) \u0026\u0026 !informed) {\n\u003e         ux_inform_user_of_update_operation(...);\n\u003e         informed \u003d true;\n\u003e     }\n\u003e }\n\u003e \n\u003e void mainboard_romstage_entry(void)\n\u003e {\n\u003e     ...\n\u003e     if (CONFIG(VBOOT_EARLY_EC_SYNC) \u0026\u0026 CONFIG(VBOOT_EC_SYNC_ESOL))\n\u003e         vboot_sync_ec();\n\u003e }\n\u003e ```\n\u003e \n\u003e Let me know if that works for you.\n\n\nI like this idea about adding cascading callbacks into the SoC/MB layer",
      "parentUuid": "7b4b868f_4ef5eb90",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eef69423_cbb4eeae",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 2
      },
      "lineNbr": 1264,
      "author": {
        "id": 3436255
      },
      "writtenOn": "2025-05-13T16:40:55Z",
      "side": 1,
      "message": "Sure, Let me implement this way then. I will abandon this CL once I put that CL up. Thanks!",
      "parentUuid": "9c293e2d_820ca576",
      "revId": "931cfe512fef5787675a689a22c217bb3b8d7d35",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}