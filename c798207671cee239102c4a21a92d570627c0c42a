{
  "comments": [
    {
      "key": {
        "uuid": "9c257137_6e0dad8c",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 255,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T00:56:08Z",
      "side": 1,
      "message": "Nononono, that\u0027s not what this code was doing. It was trying to read the flags, and *if* that failed, it would set suitable defaults for recovery mode or error out otherwise. The expected case is still that the read succeeds and then recovery mode works same as normal.\n\nI think since you have the recovery mode default handling hidden in the secdata functions now, you don\u0027t need to special case anything here anymore. Just do\n\n flags \u003d vb2_secdata_firmware_get(...);\n\nand everything should work itself out automatically.",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0f133bc5_187427f9",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 255,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-02T08:12:53Z",
      "side": 1,
      "message": "Still a bit confused here... one of the test cases is depending on VB2_NV_DISABLE_DEV_REQUEST being left alone if secdata_firmware can\u0027t be accessed.  I guess the idea is that if secdata_firmware is broken, it may start working on a subsequent boot, in which case we should keep VB2_NV_DISABLE_DEV_REQUEST around?\n\nOr should we just get rid of this extra logic and remove the test case?",
      "parentUuid": "9c257137_6e0dad8c",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59bfece1_2175160b",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 255,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T21:51:04Z",
      "side": 1,
      "message": "Hmm... yeah, okay, that\u0027s an issue. In that case, let\u0027s keep the use_secdata as it is but set it to (sd-\u003eflags \u0026 SECDATA_INIT) instead. That should mimic the old behavior.\n\nedit: looks like you already have it that way, great",
      "parentUuid": "0f133bc5_187427f9",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f853b6e7_784e6f57",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 255,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-03T08:39:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "59bfece1_2175160b",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c1ed2ed_3b15f2a2",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 265,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T00:56:08Z",
      "side": 1,
      "message": "(Can get rid of this and always assume it\u0027s 1, then.)",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c77e15ab_40098740",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 265,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-02T08:12:53Z",
      "side": 1,
      "message": "What about the case below?\n\nIf vb2ex_tpm_clear_owner fails \u0026\u0026 use_secdata, then call vb2api_fail.\n\nI think we are changing the behaviour here in the case that we are in recovery mode?  Although if we are already in recovery mode, I don\u0027t think calling vb2api_fail actually does anything anyways.",
      "parentUuid": "9c1ed2ed_3b15f2a2",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82c00e43_b57fd26d",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 265,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T21:51:04Z",
      "side": 1,
      "message": "Yes, I think if we have valid secdata but the owner clear fails somehow, when we are in recovery mode we\u0027d still want to continue. But vb2api_fail() should already happen to work out like that.",
      "parentUuid": "c77e15ab_40098740",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ea59d6b_83c9757f",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 1
      },
      "lineNbr": 265,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-03T08:39:31Z",
      "side": 1,
      "message": "Yeah, doesn\u0027t seem like calling vb2api_fail multiple times is the end of the world.",
      "parentUuid": "82c00e43_b57fd26d",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f85a245d_d6ca0dff",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 87,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T00:56:08Z",
      "side": 1,
      "message": "Why not just \u0027return 0\u0027 like you had in the FWMP code? (We can worry about non-zero defaults when we have any, which is probably going to be never.)",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb7ebd03_c2724ffd",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 87,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-02T08:12:53Z",
      "side": 1,
      "message": "Let\u0027s just use the same flow as you suggested for the setter function.",
      "parentUuid": "f85a245d_d6ca0dff",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "163362ab_8cd83209",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T00:56:08Z",
      "side": 1,
      "message": "This seems like a very complicated way of just calling \u0027return\u0027 right up there in line 122.",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5d48d7a_033f14a7",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-02T08:12:53Z",
      "side": 1,
      "message": "Original purpose was to avoid returning 0 on invalid parameter.  But I guess that\u0027s the desired behaviour (in recovery mode).",
      "parentUuid": "163362ab_8cd83209",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2218675_37131f9f",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T00:56:08Z",
      "side": 1,
      "message": "Hmmm... this one still worries me a little. As long as the only assertion we had was that \u0027param\u0027 is in range, that was probably fine even for recovery mode. But here we\u0027re checking \u0027value\u0027 which might be influenced by runtime data. We don\u0027t want recovery mode to fail to boot because we forgot an overflow check somewhere.\n\nHow about replacing the whole scheme for these functions with something slightly different:\n\n char *msg;\n\n if (!(status \u0026 INIT)) {\n   msg \u003d \"set before init\";\n   goto fail;\n }\n\n ...\n\n switch (param) {\n case FLAGS:\n   if (value \u003e 0xff) {\n     msg \u003d \"flags out of range\";\n     goto fail;\n   }\n ...\n default:\n   msg \u003d \"invalid param\";\n   goto fail;\n }\n\n ...\n\n return;\n\n fail:\n if (ctx-\u003eflags \u0026 RECOVERY)\n   VB2_DEBUG(\"ERROR [%s] ignored in recovery mode\\n\", msg);\n else\n   VB2_DIE(msg);\n\nAlternatively (if you don\u0027t like too much goto), could also define a RETURN_OR_DIE(ctx, msg) macro for this sort of stuff.",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6973078_a4ad4c52",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-02T08:12:53Z",
      "side": 1,
      "message": "OK... that\u0027s a pretty good idea.  Assuming that we also want to return a default value of 0 for invalid params in recovery mode, this flow works well.  Given that we want to use this in both the getter (return uint32_t) and the setter (return void), the macro might be a bit complex to bother with.\n\nAlthough -- the more VB2_DIE calls we start sprinkling around, the more I wonder whether depthcharge should try to boot into recovery mode instead of just dying on vb2ex_abort()?  (That is, if it is not already in recovery mode, which hopefully shouldn\u0027t happen.)",
      "parentUuid": "d2218675_37131f9f",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7915fcf4_eab89310",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T21:51:04Z",
      "side": 1,
      "message": "The idea about VB2_DIE() was that it should only be called in cases that we *know* can\u0027t happen (of course, assuming we don\u0027t make mistakes, but when we do a clean death is better than undefined behavior). All of the ones in here can\u0027t happen because vboot should already abort and enter recovery mode when secdata_init() fails earlier (and we should have a unit test to check that, I hope... i.e. that when you boot in normal mode with broken secdata, it goes into recovery rather than calling abort()). When we are in recovery mode, we continue running after secdata_init() fails, that\u0027s why we need to pay more attention in that case (and we should also make sure we have a unit test for that -- that we can boot all the way through to a recovery image even when various secdatas are broken).",
      "parentUuid": "c6973078_a4ad4c52",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb3ff1fb_b3dacd68",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-03T08:39:31Z",
      "side": 1,
      "message": "I guess the point I\u0027m trying to make is that we are relying on the caller (depthcharge) calling things in the right order for these VB2_DIE cases to *not* arise.  It\u0027s perfectly possible for a bug to be introduced in RW depthcharge, in which case vb2ex_abort may end up getting called after a firmware update.",
      "parentUuid": "7915fcf4_eab89310",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c399f177_f348df9a",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-04T00:31:32Z",
      "side": 1,
      "message": "I think that\u0027s fair. vboot has to rely on some guarantees from the caller, especially when it\u0027s split out across many functions. We should make sure we document those requirements clearly in the docstrings, and if the caller violates that then, well, it gets an abort.\n\nCan you please double-check that we have tests for this (booting in recovery mode when various types of data are invalid, for both firmware and kernel part)? From a cursory glance I couldn\u0027t find any. If we don\u0027t then we should add some, making sure that recovery mode stays working in all cases is especially important.",
      "parentUuid": "cb3ff1fb_b3dacd68",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0e722b0_cdcd62a1",
        "filename": "firmware/2lib/2secdata_firmware.c",
        "patchSetId": 1
      },
      "lineNbr": 141,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-04T07:14:00Z",
      "side": 1,
      "message": "Yes, sounds good.  Presumably we just need to worry about nvdata and secdata, since those are the ones which we are changing to call vb2ex_abort().",
      "parentUuid": "c399f177_f348df9a",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0f0dfaf_a55f6142",
        "filename": "firmware/lib20/api_kernel.c",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-10-02T00:56:08Z",
      "side": 1,
      "message": "Uhhh... you messed some more stuff up here. ;)",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48fb14c2_0225d736",
        "filename": "firmware/lib20/api_kernel.c",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-10-02T08:12:53Z",
      "side": 1,
      "message": "Argh, thanks.  Can you double-check I got it right this time?",
      "parentUuid": "f0f0dfaf_a55f6142",
      "revId": "c798207671cee239102c4a21a92d570627c0c42a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}