{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2b21b792_e735c9f2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-07-18T09:56:44Z",
      "side": 1,
      "message": "Do you see compilation issue because the GBB macro not found ?",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bee60719_8daab79c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1558987
      },
      "writtenOn": "2024-07-18T20:03:52Z",
      "side": 1,
      "message": "There were no compilation issues but still I couldn\u0027t find the new GBB",
      "parentUuid": "2b21b792_e735c9f2",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77269546_0cf0f60b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1558987
      },
      "writtenOn": "2024-07-18T20:03:52Z",
      "side": 1,
      "message": "There were no compilation issues, but I still couldn\u0027t find the new GBB with the image. It seems the current changes are not enough to create a new GBB.",
      "parentUuid": "2b21b792_e735c9f2",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5698ab4_d46dabae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-07-19T02:13:23Z",
      "side": 1,
      "message": "\u003e There were no compilation issues but still I couldn\u0027t find the new GBB\n\ncheck coreboot code about adding gbb (makefile.mk)\n\nas requested did you check with Julius and Yu-ping about adding new gbb name for csme sync test enforcement",
      "parentUuid": "bee60719_8daab79c",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a167277_cfca4a57",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1558987
      },
      "writtenOn": "2024-07-26T23:09:35Z",
      "side": 1,
      "message": "Yes, I took help form Mr. Yu-ping. The new CSME GBB is reflecting in the futility GBB list.\nCoreboot makefile changes: chromium:5741120",
      "parentUuid": "f5698ab4_d46dabae",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7126afa3_4fcd2c98",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-07-30T01:22:16Z",
      "side": 1,
      "message": "Not against adding a flag like this if it helps with testing, but... does the system ever actually boot all the way if you have this set? Doesn\u0027t CSME sync always include a reset at the end? If this flag causes a reboot loop, is that actually useful for testing?\n\nNormally when we test sync features (e.g. EC sync) we tend to instead modify the part of the image that tells coreboot whether it is different from the currently installed one (e.g. version number or whatever it has). Is that approach not possible for the CSME case?",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c4635a0_73d8278b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1558987
      },
      "writtenOn": "2024-07-30T03:52:23Z",
      "side": 1,
      "message": "Yes, indeed, the device will go into a loop if we rely solely on the GBB flag. The current firmware design has two preconditions for forced CSE sync:\n\n1. The boot partition should be RO.\n2. GBB should be forced CSME.\n\nOnce both conditions are met, CSE will trigger a forced CSE sync, an RO to RW switch, and a global reset.\nSo, in the next cycle, the system will boot in RW, hence no boot loop. \nThe firmware changes are currently implemented and verified in chromium:5705989 and chromium:574358.",
      "parentUuid": "7126afa3_4fcd2c98",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ab662a5_f4501b29",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-07-30T04:06:25Z",
      "side": 1,
      "message": "\u003e Yes, indeed, the device will go into a loop if we rely solely on the GBB flag. The current firmware design has two preconditions for forced CSE sync:\n\u003e \n\u003e 1. The boot partition should be RO.\n\u003e 2. GBB should be forced CSME.\n\u003e \n\u003e Once both conditions are met, CSE will trigger a forced CSE sync, an RO to RW switch, and a global reset.\n\u003e So, in the next cycle, the system will boot in RW, hence no boot loop. \n\u003e The firmware changes are currently implemented and verified in chromium:5705989 and chromium:574358.\n\nAlso read the design doc go/faft-cse-update if interested. It talks about complete flow.\n\n@dinesh, can you please push the coreboot side changes in upstream first. I want to get that review at the earliest.",
      "parentUuid": "6c4635a0_73d8278b",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8ec7c3a_8aa199e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-07-30T04:12:03Z",
      "side": 1,
      "message": "\u003e \u003e Yes, indeed, the device will go into a loop if we rely solely on the GBB flag. The current firmware design has two preconditions for forced CSE sync:\n\u003e \u003e \n\u003e \u003e 1. The boot partition should be RO.\n\u003e \u003e 2. GBB should be forced CSME.\n\u003e \u003e \n\u003e \u003e Once both conditions are met, CSE will trigger a forced CSE sync, an RO to RW switch, and a global reset.\n\u003e \u003e So, in the next cycle, the system will boot in RW, hence no boot loop. \n\u003e \u003e The firmware changes are currently implemented and verified in chromium:5705989 and chromium:574358.\n\u003e \n\u003e Also read the design doc go/faft-cse-update if interested. It talks about complete flow.\n\u003e \n\u003e @dinesh, can you please push the coreboot side changes in upstream first. I want to get that review at the earliest.\n\n\u003e Normally when we test sync features (e.g. EC sync) we tend to instead modify the part of the image that tells coreboot whether it is different from the currently installed one (e.g. version number or whatever it has). Is that approach not possible for the CSME case?\n\nIn order to tell CSE if there is upgrade or downgrade blob is available, we also need to provide the newer binary. This would cause two issues\n\n1. During very first release of Intel CSE blob, there is no \"N-1\" blob available\n2. To support the CSE sync idea, we always need to maintain N and N-1 copy into our repository. This would cost the SPI size issue. Also, not all N-1 and N blobs are compatible during dev cycle.\n\nHence, we have designed go/faft-cse-update to ensure we are testing three things\n\n1. CSE updater logic code\n2. CSE RW read/write/erase function\n3. Able to boot to OS after flashing the CSE RW blob\n\nHope it clarifies why we are coming with idea of enforced CSE sync.",
      "parentUuid": "6ab662a5_f4501b29",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3249a48e_d9bcfc76",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2024-07-30T06:52:28Z",
      "side": 1,
      "message": "Have we ever considered the solution of modifying the CSE version in CBFS (both the version bytes in `me_rw` and the version file `me_rw.version`) in FAFT, similar to the `firmware.SoftwareSync` test? Then we won\u0027t have to implement custom logic in firmware. I imagine the FAFT test can do the following:\n\n1. Read the AP image as `ap.bin`\n2. Extract CBFS file `me_rw` from `ap.bin` as `me_rw.new`\n3. Modify the version bytes in `me_rw.new` (offsets 16 18 20 22)\n4. Create the new version file `me_rw.new.version`\n5. Replace CBFS files `me_rw` and `me_rw.version` with `me_rw.new` and `me_rw.new.version` in `ap.bin`\n6. Resign `ap.bin` and do whatever needed to make it a valid image\n7. Flash the modified `ap.bin` to DUT\n\nThe benefit is that the update flow will be closer to the one actually happening on a real user\u0027s device. In particular, we can test the CSE RW update flow when CSE is running RW partition (i.e., DUT switching to CSE RO -\u003e updating CSE RW -\u003e switching back to the new RW).",
      "parentUuid": "b8ec7c3a_8aa199e9",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a69fa6b9_f0930a49",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-07-30T07:10:47Z",
      "side": 1,
      "message": "\u003e Have we ever considered the solution of modifying the CSE version in CBFS (both the version bytes in `me_rw` and the version file `me_rw.version`) in FAFT, similar to the `firmware.SoftwareSync` test? Then we won\u0027t have to implement custom logic in firmware. I imagine the FAFT test can do the following:\n\u003e \n\u003e 1. Read the AP image as `ap.bin`\n\u003e 2. Extract CBFS file `me_rw` from `ap.bin` as `me_rw.new`\n\u003e 3. Modify the version bytes in `me_rw.new` (offsets 16 18 20 22)\n\u003e 4. Create the new version file `me_rw.new.version`\n\u003e 5. Replace CBFS files `me_rw` and `me_rw.version` with `me_rw.new` and `me_rw.new.version` in `ap.bin`\n\u003e 6. Resign `ap.bin` and do whatever needed to make it a valid image\n\u003e 7. Flash the modified `ap.bin` to DUT\n\u003e \n\u003e The benefit is that the update flow will be closer to the one actually happening on a real user\u0027s device. In particular, we can test the CSE RW update flow when CSE is running RW partition (i.e., DUT switching to CSE RO -\u003e updating CSE RW -\u003e switching back to the new RW).\n\nIn such case, system will be always in boot loop because the actual ME RW version and tweaked ME RW (CBFS file) won\u0027t be matching. We won\u0027t be able to complete the OS booting to conclude the test.",
      "parentUuid": "3249a48e_d9bcfc76",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80a499fc_e5d2c1cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2024-07-30T07:12:59Z",
      "side": 1,
      "message": "By modifying the version bytes (offsets 16 18 20 22), do we NOT change the actual ME RW version? If not, where\u0027s the source of truth of the actual ME RW version?",
      "parentUuid": "a69fa6b9_f0930a49",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a0d4af7_887ecaf4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-07-30T07:20:28Z",
      "side": 1,
      "message": "\u003e By modifying the version bytes (offsets 16 18 20 22), do we NOT change the actual ME RW version? If not, where\u0027s the source of truth of the actual ME RW version?\n\nno, to change actual ME RW binary (CSE RW FW), we need to rerun the MFIT tool to regenerate the CSE blob.\n\nME RW version stays inside the ME binary and the CBFS file is our metadata to check if the currently running CSE binary has different version that CBFS store meta data file.\n\nAssume case,\n\n1. currently running CSE RW binary is 18.0.5.1234\n2. You have new CSE RW blob 18.0.5.5678 in CBFS and metadata file in CBFS also 18.0.5.5678\n\nResult, we are able to perform the CSE update and boot to OS\n\n1. currently running CSE RW binary is 18.0.5.5678\n2. You have same CSE RW blob 18.0.5.5678 in CBFS and metadata file in CBFS says 18.0.5.9000\n\nresult, system will assume there is newer binary as issue CSE sync because `18.0.5.5678!\u003d18.0.5.9000` but on next boot, it will again run into same version mismatch. This will be eternal process of CSE sync. So, we can\u0027t fake any version in CBFS meta data file which is used to check the CSE sync logic.",
      "parentUuid": "80a499fc_e5d2c1cb",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee438b02_f2f75a1d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2024-07-30T09:27:39Z",
      "side": 1,
      "message": "\u003e no, to change actual ME RW binary (CSE RW FW), we need to rerun the MFIT tool to regenerate the CSE blob.\n\nYes I know modifying the CBFS file `me_rw.version` is not enough. By \"version bytes\" I meant the CSE RW blob (such as `me_rw-karis4es.bin`). Coreboot\u0027s Makefile generates `me_rw.version` by reading specific offsets from the CSE RW blob. Therefore I thought the source of truth of version info is stored within those offsets, and hence we should be able to modify it.\n\nNow I just found b/327842062. It looks like the version info cannot be extracted from a PTL CSE blob, which means modifying the version is also infeasible (at least for PTL).\n\nLet\u0027s proceed with the GBB flag solution.",
      "parentUuid": "3a0d4af7_887ecaf4",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b23e3800_cd945b5c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-07-30T21:18:36Z",
      "side": 1,
      "message": "Thanks for the explanation, sounds like you thought this through and I agree the GBB flag seems like a good solution in this case.",
      "parentUuid": "ee438b02_f2f75a1d",
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a82b5993_515a9970",
        "filename": "firmware/2lib/include/2gbb_flags.h",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2024-07-30T09:27:39Z",
      "side": 1,
      "message": "Or `CSE`?",
      "range": {
        "startLine": 97,
        "startChar": 12,
        "endLine": 97,
        "endChar": 16
      },
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a5a6d7d_29ac3afd",
        "filename": "firmware/2lib/include/2gbb_flags.h",
        "patchSetId": 1
      },
      "lineNbr": 97,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2024-07-30T09:27:39Z",
      "side": 1,
      "message": "`sync`",
      "range": {
        "startLine": 97,
        "startChar": 17,
        "endLine": 97,
        "endChar": 21
      },
      "fixSuggestions": [
        {
          "fixId": "7ebc394e_cec275ce",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "firmware/2lib/include/2gbb_flags.h",
              "range": {
                "startLine": 97,
                "startChar": 0,
                "endLine": 98,
                "endChar": 0
              },
              "replacement": "\t/* Enforce CSME sync, even if current CSME is same as CBFS CSME */\n"
            }
          ]
        }
      ],
      "revId": "1dc60ecb3672c2e02f880ff26b1217ccb938569f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}