{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "46f5b33b_e4e7c379",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 96,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-21T19:36:29Z",
      "side": 1,
      "message": "Move back to original (reformats make things harder to review)",
      "range": {
        "startLine": 96,
        "startChar": 1,
        "endLine": 96,
        "endChar": 55
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73f8b52f_d9087dec",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 96,
      "author": {
        "id": 1570422
      },
      "writtenOn": "2023-06-23T04:11:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "46f5b33b_e4e7c379",
      "range": {
        "startLine": 96,
        "startChar": 1,
        "endLine": 96,
        "endChar": 55
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea6a5fc8_b517fe29",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-21T19:36:29Z",
      "side": 1,
      "message": "Same for the tabs.",
      "range": {
        "startLine": 123,
        "startChar": 1,
        "endLine": 123,
        "endChar": 2
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb33e9f1_1a72ebb6",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1570422
      },
      "writtenOn": "2023-06-23T04:11:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ea6a5fc8_b517fe29",
      "range": {
        "startLine": 123,
        "startChar": 1,
        "endLine": 123,
        "endChar": 2
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3ed73d1_fe7ae245",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 139,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-21T19:36:29Z",
      "side": 1,
      "message": "Printing such a string is not \"machine friendly\"\n\nYou should be printing an error, not to stdout.",
      "range": {
        "startLine": 135,
        "startChar": 1,
        "endLine": 139,
        "endChar": 2
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d89270ec_a28d6878",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 139,
      "author": {
        "id": 1570422
      },
      "writtenOn": "2023-06-23T04:11:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c3ed73d1_fe7ae245",
      "range": {
        "startLine": 135,
        "startChar": 1,
        "endLine": 139,
        "endChar": 2
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a73681ba_a3923c1d",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 168,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-21T19:36:29Z",
      "side": 1,
      "message": "ditto + others",
      "range": {
        "startLine": 168,
        "startChar": 1,
        "endLine": 168,
        "endChar": 3
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "058f128b_f1763b47",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 168,
      "author": {
        "id": 1570422
      },
      "writtenOn": "2023-06-23T04:11:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a73681ba_a3923c1d",
      "range": {
        "startLine": 168,
        "startChar": 1,
        "endLine": 168,
        "endChar": 3
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61a9bf61_a5de420b",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-21T19:36:29Z",
      "side": 1,
      "message": "This seems way too easy to break with minimal changes + a huge problem when devs start using it and requires a change here.\n\nIf you want devs to start using this format seriously, it needs to be more stable.\nRecommend using json with actual well defined keys or some other format.",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "191e54f8_d7ec7f96",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-06-22T00:21:23Z",
      "side": 1,
      "message": "I disagree with the JSON, not every shell script that quickly tries to parse some value has access to a JSON parser. The goal here is not to serialize this full data block, it is to make it as easy as possible for any other process (written in anything, even in environments with restricted dependencies) to parse a few individual fields they may try to query. I think this format is a good solution because it easily allows you to extract any field with just a grep+cut or a simple regex match. We just need to fine-tune the individual field names to have more regularity (see my other comments), and then of course there should be an understanding that once a field has been added, it needs to be supported indefinitely (or at least deprecated very carefully).",
      "parentUuid": "61a9bf61_a5de420b",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1feeeec_e502aa5b",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-22T00:59:55Z",
      "side": 1,
      "message": "Agree on the disagreement :)\n\nIf futility owners are fine with this approach, I can\u0027t say much.\n\nIf anything, future upload/changes can utilize `--json` as an option to spit out JSON as the preferred format.\nThere is also `jq` in ChromeOS installations or scripts to leverage now.",
      "parentUuid": "191e54f8_d7ec7f96",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78e372a8_7775531f",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-06-22T01:12:36Z",
      "side": 1,
      "message": "Agree that we could still add JSON output separately later if we wanted to. I don\u0027t really see why, though, I think this solution should work well for the use cases I foresee here. I know there\u0027s `jq` for scripts but I don\u0027t see the point of creating a solution that relies on that always being available when we can just solve the same use cases with something that doesn\u0027t need any extra libraries or tools to parse. futility needs to run in many different environments (normal ChromeOS, recovery initramfs, signer hosts, random upstream coreboot people trying to use vboot, etc.) so we really try avoid dependencies wherever possible.",
      "parentUuid": "c1feeeec_e502aa5b",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bba732fe_e53e1878",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-22T01:24:16Z",
      "side": 1,
      "message": "\u003eso we really try avoid dependencies wherever possible.\n\nAgree with you this is a good reason to avoid JSON, but JSON could definitely still help benefit the users/cases that *have* the dependencies already and..\n\nIn terms of miniOS/CrOS use cases (which the author will be using), there are handy libchrome + libbrillo dependencies already which help parse JSON.\nWhile the current outputs would be a string match/search (which is fine/good until, what needs to be printed start requiring the delimiter values, the output gets \"heavier\" because the multiple prefixes might need to get printed)\n\nAnother option might be to allow printing each individual piece like:\n`futility -p kernel.size` -\u003e stdout:`123`\n`futility -p kernel.X` -\u003e stdou:`foobar`\nin which case we don\u0027t need to worry about the output format at all(?)\n\nPlease ignore JSON / defer potentially for future iterations :P",
      "parentUuid": "78e372a8_7775531f",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c35d3bb8_a386e0a1",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-06-22T01:34:34Z",
      "side": 1,
      "message": "\u003e While the current outputs would be a string match/search (which is fine/good until, what needs to be printed start requiring the delimiter values, the output gets \"heavier\" because the multiple prefixes might need to get printed)\n\nWell, part of this exercise is to figure out if there are any cases where that model doesn\u0027t work well, like you\u0027re suggesting here. ;) Let\u0027s see how it looks once Saketh has implemented this for all `show` output. I don\u0027t think futility has a case where that\u0027s really going to be a problem, but maybe I\u0027m wrong and then we can discuss it when we see it. We\u0027re not trying to design a universal data serialization format here, after all, just something that can output what futility needs to output.\n\n\u003e Another option might be to allow printing each individual piece like:\n\nYeah, I thought about that option too, that would be the next best alternative. That gets a lot more complicated inside futility itself though, since you can no longer just run through the same code that the human-readable `show` runs through and just modify the print statements, you now have to implement a full parser for all valid input indentifiers and then figure out for each of them exactly what data structures you need to unpack to get to that answer. Ultimately, since runtime isn\u0027t really important for this feature (so we don\u0027t really care about wasting time printing \"too much\") and since basically every caller ever no matter what it is written in should be easily able to do the equivalent of a grep and cut, I don\u0027t think we gain anything there that\u0027s worth the extra effort, and I think the solution implemented here is still the best combination of easy to implement and useful for all expected use cases.",
      "parentUuid": "bba732fe_e53e1878",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fe2ae6d8_e84bf309",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2023-06-22T03:00:07Z",
      "side": 1,
      "message": "\u003esomething that can output what futility needs to output.\n\u003eeasy to implement and useful for all expected use cases.\n\nSounds good to me for the use cases today!\n\n(Maybe someone can go ahead and implement other stabler formats - like JSON or the alternative option for single arguments as a side gig / when necessary) :P\n\nAck\u0027ing eagerly as I don\u0027t think current outputs would break from the pseudo format.",
      "parentUuid": "c35d3bb8_a386e0a1",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5f057d8_bbf7b29e",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1000768
      },
      "writtenOn": "2023-06-23T19:17:41Z",
      "side": 1,
      "message": "JSON is a known stable format.  this is proposing a completely new unique format that no one else understands.  i don\u0027t see how \"everyone has to write a bespoke parser with their own bugs\" is better than \"just use JSON like everyone else, and if you want to write shell scripts, use jq\".\n\nhttps://www.chromium.org/chromium-os/platform/#data-serialization",
      "parentUuid": "fe2ae6d8_e84bf309",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5853aaf_0cebc625",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1000768
      },
      "writtenOn": "2023-06-27T14:41:38Z",
      "side": 1,
      "message": "i also don\u0027t buy the \"i have a full shell environment, but i can\u0027t afford a JSON parser\" argument.  this smells like a general bias against JSON because it has origins in JavaScript, and JS is \"big and bloated\".  i\u0027ll point out that `jq` is significantly smaller than bash, and on the order of grep or sed.  it\u0027s not part of POSIX and thus won\u0027t have as much portability, but we shouldn\u0027t be making bad decisions because something isn\u0027t in POSIX.\n\nif you want to talk about embedded systems with extreme size constraints, then *maybe*, but those aren\u0027t relevant to this code as they wouldn\u0027t be creating a futility program to pipe+fork+exec in the first place.  plus, there are extremely tiny JSON C parsers out there (like [jsmn](https://github.com/zserge/jsmn)).\n\nencouraging people to use grep+cut means driving them to fragile solutions.  this format is forcing the input name as the prefix, and that is a filesystem path that can have any byte value, including spaces \u0026 colons \u0026 newlines.  \"the user should just know not to do that\" is not reasonable -- if the format is designed poorly in the first place, it\u0027s the format\u0027s fault.  how the caller arrived at a particular name can take many routes -- maybe it\u0027s a local file on disk and the path (parent or file itself) contains those values.  or it\u0027s a /dev path that is found via bus or label paths.\n\nif you really want some buggy bespoke format, go for it, but don\u0027t do it *instead of* JSON.  we need reliable formats in CrOS, we\u0027re already shipping `jq` in the rootfs \u0026 minios \u0026 factory, and should be trivial to include in recovery images.",
      "parentUuid": "e5f057d8_bbf7b29e",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f95511a_71104b03",
        "filename": "futility/cmd_show.c",
        "patchSetId": 6
      },
      "lineNbr": 543,
      "author": {
        "id": 1570422
      },
      "writtenOn": "2023-06-27T15:18:55Z",
      "side": 1,
      "message": "From an implementation standpoint, I think we would go down the route of parallel functions for printing in JSON vs regular print. As I\u0027ve been modifying print functions in `futility/file_type_bios.c` I\u0027ve been running into cases where `FT_PRINT` starts to become unweildy. \nSince I\u0027m the only user atm, and I really only care about a specific set of values, I would like to suggest this impl again: https://chromium-review.googlesource.com/c/chromiumos/platform/vboot_reference/+/4609016 as the easiest way forward.\nJSON/Psuedo format is still viable, and I have some WIP changes locally handling other file types, but the code here will probably start to have parallel paths to support the nice formatting we have now and the parseable format we\u0027d like to add.\nSimilar too with the individual piece that Jae suggested above, I could see that being a seperate executable entirely since the logic/flows could be so different",
      "parentUuid": "f5853aaf_0cebc625",
      "range": {
        "startLine": 522,
        "startChar": 2,
        "endLine": 543,
        "endChar": 61
      },
      "revId": "ecb7d248761457bdcaec4cb1ffbce881b906a168",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}