{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0938cc2d_2ddee614",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-08-15T01:26:21Z",
      "side": 1,
      "message": "I\u0027m honestly wondering if there\u0027s a point in hashing this, as opposed to just putting the raw version number in the lowest 4 bytes and zeroing the rest. I know that\u0027s how it\u0027s intended to be used, but it\u0027s also intended to be used with much larger data buffers, and it shouldn\u0027t make a difference (since the process of extension itself hashes it again anyway). I think firing up the SHA algorithm again here would just be a waste of time (although it\u0027s probably pretty fast for one block).\n\n+Andrey, what do you think?",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05ab8f33_11c982bd",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1152319
      },
      "writtenOn": "2023-08-23T00:49:33Z",
      "side": 1,
      "message": "1) yeah, I\u0027d just extend the \u002700..00\u003cver\u003e\u0027 value instead of hashing it. all those level of indirection only complicate things w/o adding to security.\n2) I know it\u0027s a bit late, but to avoid growing the compatibility gap between CrOS use of PCRs and other systems use of PCRs, how about we use NV spaces with TPMA_NV_EXTEND/TPM_NT_EXTEND + TPMA_NV_CLEAR_STCLEAR attributes (+ I suggest TPMA_NV_ORDERLY to avoid committing it to flash), which behave like PCRs. But instead of spending one of 16 PCR indices we spend just one of 2^24 nv indices, and avoid potential compatibility issues.\nthat would require creating those spaces with platform auth if they are not created yet, but we have code for that already.",
      "parentUuid": "0938cc2d_2ddee614",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d155c3e_b4d5699a",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1152319
      },
      "writtenOn": "2023-08-23T00:55:59Z",
      "side": 1,
      "message": "and then :) if we switch to nv spaces, why do we even care about PCR-like-extending model and TPMA_NV_EXTEND/TPM_NT_EXTEND. just use TPMA_NV_WRITE_STCLEAR + TPMA_NV_CLEAR_STCLEAR and do Write+WriteLock (we also have code for that). actually, even TPMA_NV_CLEAR_STCLEAR is optional. just overwrite on every boot and then Lock. instead of digests, use version as-is. GSC code then can just take the version from this field and insert into the cert as-is (w/o the need to capture the extended value at PCR_Write or without the need for cert consumer to track digest-to-version mapping if the want to enforce version\u003e\u003dX policy).",
      "parentUuid": "05ab8f33_11c982bd",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a99bc051_a8ef84b9",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1293547
      },
      "writtenOn": "2023-08-23T02:29:04Z",
      "side": 1,
      "message": "The downside of write + write lock is the extra two TPM commands in the boot flow.\nIs that acceptable from the fw point of view?",
      "parentUuid": "8d155c3e_b4d5699a",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49e129e2_faa3d70d",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1152319
      },
      "writtenOn": "2023-08-23T02:36:11Z",
      "side": 1,
      "message": "for kernel version we technically could do just PPWRITE and since we lock platform hierarchy before jumping to kernel, nobody will be able to change it.\nessentially, use exactly the approach we use for antirollback spaces:\n- rely on WRITE_STCLEAR and WriteLock for fw antirollback (and now fw version)\n- rely on PPWRITE and hierarchy disable for kernel antirollback (and now kernel version)",
      "parentUuid": "a99bc051_a8ef84b9",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf410955_5bb590bb",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-08-23T21:30:18Z",
      "side": 1,
      "message": "I think I agree with Yi Chou here, isn\u0027t the PCR option still preferable? One command less is still 33% faster for the feature as a whole (and we already have a lot more GSC communication overhead than we want to to begin with). We\u0027ve gotten up to 5 out of 16 PCRs in 10+ years of ChromeOS, I don\u0027t think we\u0027re in that much of a danger of running out? (Besides, does the TPM spec even mandate an exact number of PCRs? I think we could just add more if we ever needed to?)\n\nThe other problem with using NVRAM is that we really need PCR-style behavior and guarantees here, and while we could try to emulate that with NVRAM APIs it would be more complicated and more likely we\u0027d make a mistake (e.g. we need to make sure both versions are stored separately in a way that the firmware can no longer overwrite the firmware version at the point it writes the kernel version).\n\nThe GSC needs custom code to capture this either way, does it make that much of a difference whether we hook into PCR_Extend or NV_Write?",
      "parentUuid": "49e129e2_faa3d70d",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac06c9e5_e9e5b74c",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1152319
      },
      "writtenOn": "2023-09-14T17:46:51Z",
      "side": 1,
      "message": "we can get one command with TPMA_NV_EXTEND/TPM_NT_EXTEND + TPMA_NV_CLEAR_STCLEAR. but what I liked about non-PCR nvmem spaces is you can actually store the value and whoever cares about it on the server side can just look at it w/o needing to keep the mapping between the version and the resulting PCR value. but if going with one command is important, let\u0027s use the PCRs.",
      "parentUuid": "cf410955_5bb590bb",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1abd6102_fae73eb9",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-09-14T18:07:11Z",
      "side": 1,
      "message": "I really feel like this is a PCR thing and trying to fit it into NVRAM semantics would be abusing the wrong API for the job. We\u0027re trying to attest something here in a way that cannot be faked by later-running code. That is traditionally a PCR\u0027s job.\n\nThe problem that the verifier also needs to know the original value to be able to compute and compare the PCR value is common to all PCR usage, but usually solved by providing that information out of band (i.e. outside of the TPM). So in this case, maybe we could just have whatever userspace component reads the final cert from the GSC and provides it to the Widevine server also provide the raw version numbers on the side?",
      "parentUuid": "ac06c9e5_e9e5b74c",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b858a3a_7fefd8c5",
        "filename": "firmware/2lib/2api.c",
        "patchSetId": 2
      },
      "lineNbr": 236,
      "author": {
        "id": 1293547
      },
      "writtenOn": "2023-09-15T06:48:02Z",
      "side": 1,
      "message": "Yeah, we have a userland plugin (hwsec-optee-plugin) that can provide the version numbers into OP-TEE if they want.\n\nAlthough I\u0027m not sure if it is a good idea to read the `tpm_fwver` \u0026 `tpm_kernver` in `crossystem`.\n\n```\ntpm_fwver   ... # [RO/int] Firmware version stored in TPM\ntpm_kernver ... # [RO/int] Kernel version stored in TPM\n```\n\nBut from the code, I think it\u0027s the current booted version...\n\nhttps://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/platform/vboot_reference/firmware/2lib/2misc.c;drc\u003d1f76c38bbda3dca283f81c8fdba9c18ad1fc4e09;l\u003d546\n\nhttps://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/platform/vboot_reference/host/lib/crossystem.c;drc\u003d525184158a9824a8e47ded3d5c0eb62b228e8d63;l\u003d344",
      "parentUuid": "1abd6102_fae73eb9",
      "revId": "658d0f4570e14a5bf39da2ecb254505b03fefa33",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}