{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e9113c3d_76444d06",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-11-12T01:00:30Z",
      "side": 1,
      "message": "_\\*sigh\\*_ I\u0027m starting to really hate these inscrutable requirements from on high... -.-\n\nIs there anything we can tweak about this requirement? Or can we maybe put our DTB into the `dtbo` partition after all, if the `dtb` partition is outlawed? Having it outside of `vendor_boot` avoids the need for another big memcpy mentioned below.\n\nI\u0027m also a bit confused, when I search for that requirement in the Android 16 docs, the one above it (VSR-3.7.4-001) says you must use \"boot image header version 2\". Is that text even up to date? I thought we were using version 4 already.",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59d3b79a_ca1b9bc2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1302633
      },
      "writtenOn": "2025-11-12T18:25:11Z",
      "side": 1,
      "message": "\u003e *sigh* I\u0027m starting to really hate these inscrutable requirements from on high... -.-\n\u003e Is there anything we can tweak about this requirement? \n\nI stumbled upon this requirement as I was updating the VTS firmwareDtboVerification test to accommodate the DTB partition. I was equally disappointed. I am not sure who to approach regarding tweaking any VTS requirement. But it may be a long pole if we have to unblock the Qcom and Mediatek bringup teams.\n\n\u003e Or can we maybe put our DTB into the dtbo partition after all, if the dtb partition is outlawed? Having it outside of vendor_boot avoids the need for another big memcpy mentioned below.\n\nIt is a balancing call in my opinion. If we have to check for the overlay property/node in the devicetree to differentiate between base DTB and overlay DTB, then with all the devicetree entries compressed we have to do memcpy there too(as we are decompressing). We have to decompress each devicetree entry and check if it is a base DTB or an overlay DTB. So we do a memcpy of just base DTB blobs like here or a memcpy of both DTB and DTBO blobs in the other approach.\n\nAnother option is to introduce a flag in the custom field to indicate whether it is a base DTB or overlay DTB. We already have 1 byte for device Identifier type. We can limit that to a nibble and borrow one bit from the remaining nibble for this DTB differentiation purpose. This approach in turn avoids an extra memcpy.",
      "parentUuid": "e9113c3d_76444d06",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23b79ca5_be7eb84a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-11-12T21:10:31Z",
      "side": 1,
      "message": "We don\u0027t have to check every entry, though, we only have to check those we are actually loading, right? So we would basically run `android_parse_dtbs()` like this:\n\n1. Iterate over all entries in the `dtbo` partition\n  2. For each entry, check `is_dt_entry_compatible()`.\n  3. If yes, run `get_dt_entry_data()`, and do the overlay test on the result.\n  4. If it\u0027s a base DTB, stash the result pointer somewhere (if there\u0027s already one stashed, error out, that\u0027s illegal)\n  5. If it\u0027s an overlay, stash the result pointer in a temporary list (or big enough stack array)\n6. After the loop, we should have one stashed base DTB pointer and a number of stashed overlay pointers, all stored in heap allocations.\n7. Apply overlays one-by-one to base DTB (ideally in the same order they appeared in the partition)\n8. Done",
      "parentUuid": "59d3b79a_ca1b9bc2",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e2b5b1db_40ce8ae5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 3487009
      },
      "writtenOn": "2025-11-11T23:39:51Z",
      "side": 1,
      "message": "Automatically set CQ+1 by AutoRunner. See go/chromeos-cqw:auto-runner-doc for details. \nReport Bugs/Feedback: go/cros-auto-runner-bug. \n",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91119e8c_e70d29e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1594262
      },
      "writtenOn": "2025-11-12T07:07:56Z",
      "side": 1,
      "message": "The previous build (https://cr-buildbucket.appspot.com/build/8698454164374327377) is being automatically retried for the following reasons:\n- Some child builders are now retryable:nissa-cq\n\nDid you notice a bug or UX issue with this retry? Please provide feedback: go/cros-auto-retry-bug.\n",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8045378f_4c7858ea",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 1
      },
      "lineNbr": 325,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-11-12T01:00:30Z",
      "side": 1,
      "message": "So, careful, things get more tricky now: we\u0027re doing some complicated ramdisk surgery inside the buffer here and we need to be careful not to trample over our own toes. When initially loaded, our kernel buffer looks like this:\n\n[GKI][vndr hdr][vndr ramdisk 1][vndr ramdisk 2][vndr ramdisk 3][dtb][vndr ramdisk table][bootconfig][init header][init ramdisk]\n\nAfter rearranging to make all used ramdisks consecutive, it can look like this:\n\n[GKI][vndr hdr][vndr ramdisk 1][vndr ramdisk 3][init ramdisk][overwritten remains]\n\nSo certain things like bootconfig, the init_boot header and unused vendor ramdisks get overwritten. That\u0027s why `save_bootconfig()` must be called up there before all this happens and copies the bootconfig into the heap.\n\nThe DTB in the vendor_boot partition is unfortunately also in the area that would get overwritten. But while the bootconfig is pretty small, the DTB could easily be a megabyte. That\u0027s why it would be preferable to have it in a separate partition behind init_boot where it is safe from overwriting. But if that\u0027s not possible, then we also need to copy it somewhere else (e.g. a heap buffer) before we start resecting the image.",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2943c80d_d31e2142",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 1
      },
      "lineNbr": 325,
      "author": {
        "id": 1302633
      },
      "writtenOn": "2025-11-12T19:37:27Z",
      "side": 1,
      "message": "Acknowledged. I did take a copy of the dtb before it gets overwritten when ramdisks are moved.",
      "parentUuid": "8045378f_4c7858ea",
      "revId": "6c3412ab2bec7424e153ca45c5a5d467edd1b75d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}