{
  "comments": [
    {
      "key": {
        "uuid": "cc5619d5_f5432dc8",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 3
      },
      "lineNbr": 219,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "Please use vb2_set_workbuf_used() (or, if you don\u0027t like that API, change it globally... we should have a consistent way to handle this stuff).",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0b3bbb2_f5c26d2d",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 3
      },
      "lineNbr": 219,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "Modified to use a new function called vb2_workbuf_to_ctx() instead.  No more need for the `used` stuff.  Is that an acceptable model?",
      "parentUuid": "cc5619d5_f5432dc8",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b48c9b49_93258163",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 3
      },
      "lineNbr": 219,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-29T21:21:59Z",
      "side": 1,
      "message": "Yes, but I think if we wanna change it we should use your new function everywhere, not have two different ways to do it.",
      "parentUuid": "e0b3bbb2_f5c26d2d",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e4c8da8_d1b44538",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 3
      },
      "lineNbr": 128,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "I think we\u0027re not gonna have a 4GB work buffer anytime soon so this can be uint32_t.",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "489cb682_667ed9c6",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 3
      },
      "lineNbr": 128,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1e4c8da8_d1b44538",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "296e1917_dcc101d6",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 3
      },
      "lineNbr": 128,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-05-03T11:10:33Z",
      "side": 1,
      "message": "Actually, one difficulty this causes is that it makes testing somewhat inconvenient for when we want to keep the GBB data outside of the workbuf (which is the case for many tests currently).  On a 64-bit system, the test may fail, since gbb_offset is not large enough to store the offset of the GBB header data structure.\n\nSome workarounds would involve:\n- Moving GBB data into the workbuf for all tests involved [which is a bit of a pain, requires rewriting somewhat large portions of the tests that involve GBB]\n- Un-inlining vb2_get_gbb and overriding the function in tests",
      "parentUuid": "489cb682_667ed9c6",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e96c0343_47d897c3",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "If you now intend for the caller to pass the size in anyway (which should be okay, I assume), you don\u0027t need to do this anymore.",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8c4a549_0b6c510d",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "Working under the assumption that:\n\n  gbb-\u003ekey_size \u003e\u003d size(VbPublicKey)\n\nThen yeah, we should be able to use the incoming size argument.\n\n\nOn the other hand, I discovered that it seems the GBB header pads keys quite a lot (I\u0027m not entirely sure why).  In the case of eve keys (\"Algorithm: 11 RSA8192 SHA512\"), the size of the actual payload is just 0x0808.  But the GBB header claims the VbPublicKey+payload size is 0x1000.\n\nLooks like futility/cmd_gbb_utility.c just stupidly accepts the sizes at command-line without checking that they match.  Not sure why the padding needs to happen, since it doesn\u0027t even align the keys nicely in flash.  The only reason I could think of is that perhaps we did not used to have the VbPublicKey structure to tell us the size of the key data -- so we would just assume the maximum size (0x1000).\n\nWell, maybe I\u0027m missing some background here.  Do you know, Julius?  Or should I ask Randall?\n\nRegardless, the different routes here are:\n\n(1) Stick with previous model: Read the header first, get the \"real size\", and then read again to get the key.\n(2) Read all of the 0x1000 bytes from flash that the GBB header specifies, and then figure out how much of that we actually need based off of the key header.\n(3) Read all of the 0x1000 bytes that the GBB header specifies, and just return that data, regardless of all the 0\u0027s at the end.",
      "parentUuid": "e96c0343_47d897c3",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b17da3d_3c572485",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-29T21:21:59Z",
      "side": 1,
      "message": "Oh, okay, I misunderstood how these sizes work a bit. I think it just shows how much space is allocated for that key in the GBB. This makes some amount of sense because keys may get replaced with others of different size by the signers (although I guess we could also just create a whole new GBB for that...).\n\nIn that case I agree that we should read the real size, but then we should make sure we also only load that from the flash, not the whole buffer (this is what the old code did but you\u0027re changing it with the vb2_load_gbb_data() above). So you want something like this:\n\n if (size \u003c sizeof(vb2_packed_key))\n   return some_error_and_maybe_print_something_idk;\n *keyp \u003d vb2_workbuf_alloc(\u0026wb, size);\n ...insert various error handling where needed...\n vb2ex_read_resource(ctx, VB2_RES_GBB, offset, *keyp,\n                     sizeof(vb2_packed_key));\n if (*keyp-\u003ekey_size \u003e size)\n   return other_error;\n vb2ex_read_resource(ctx, VB2_RES_GBB, offset + sizeof(vb2_packed_key),\n                     ((u8)*keyp) + sizeof(vb2_packed_key),\n                     *keyp-\u003ekey_size - sizeof(vb2_packed_key));",
      "parentUuid": "f8c4a549_0b6c510d",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2b9c1f1_da65ccda",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "See my comment on... where was it... idk, somewhere else: I don\u0027t think there\u0027s a need to cache any of these, since the only time we need them more than once is in display use cases (where speed isn\u0027t critical). I\u0027d just always load them on demand. Let\u0027s keep it simple.",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2034a3c_d928181b",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "This does raise a question -- if we are guaranteed to have DRAM up by the time we get to kernel verification stage, why do we even need a (larger) workbuf?  Can\u0027t we just use malloc/free?",
      "parentUuid": "e2b9c1f1_da65ccda",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b328fa31_c9a26258",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-29T21:21:59Z",
      "side": 1,
      "message": "I think some functions are shared between firmware and kernel verification, so those obviously use the workbuf, and if kernel verification wants to call them it also needs to provide a workbuf that can still grow a bit. It probably doesn\u0027t need a whole megabyte. For anything that\u0027s kernel-verification-only, yes, just using malloc() should be fine.\n\nActually, reading all this (and the problems of loading too much from flash), I think it would be nice to write it in a way that could also be used by firmware verification. vb2_load_fw_keyblock() currently loads the whole rootkey_size from the GBB, but if we write a better function for that here, we should also be using it there. (These functions should probably all go into lib20/misc.c or lib20/packed_key.c then, this file is an old vboot1 file that should eventually get removed anyway.)",
      "parentUuid": "c2034a3c_d928181b",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}