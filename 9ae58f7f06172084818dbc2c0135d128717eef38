{
  "comments": [
    {
      "key": {
        "uuid": "cc5619d5_f5432dc8",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 3
      },
      "lineNbr": 219,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "Please use vb2_set_workbuf_used() (or, if you don\u0027t like that API, change it globally... we should have a consistent way to handle this stuff).",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0b3bbb2_f5c26d2d",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 3
      },
      "lineNbr": 219,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "Modified to use a new function called vb2_workbuf_to_ctx() instead.  No more need for the `used` stuff.  Is that an acceptable model?",
      "parentUuid": "cc5619d5_f5432dc8",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e4c8da8_d1b44538",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 3
      },
      "lineNbr": 128,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "I think we\u0027re not gonna have a 4GB work buffer anytime soon so this can be uint32_t.",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "489cb682_667ed9c6",
        "filename": "firmware/2lib/include/2struct.h",
        "patchSetId": 3
      },
      "lineNbr": 128,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1e4c8da8_d1b44538",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e96c0343_47d897c3",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "If you now intend for the caller to pass the size in anyway (which should be okay, I assume), you don\u0027t need to do this anymore.",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8c4a549_0b6c510d",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 62,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "Working under the assumption that:\n\n  gbb-\u003ekey_size \u003e\u003d size(VbPublicKey)\n\nThen yeah, we should be able to use the incoming size argument.\n\n\nOn the other hand, I discovered that it seems the GBB header pads keys quite a lot (I\u0027m not entirely sure why).  In the case of eve keys (\"Algorithm: 11 RSA8192 SHA512\"), the size of the actual payload is just 0x0808.  But the GBB header claims the VbPublicKey+payload size is 0x1000.\n\nLooks like futility/cmd_gbb_utility.c just stupidly accepts the sizes at command-line without checking that they match.  Not sure why the padding needs to happen, since it doesn\u0027t even align the keys nicely in flash.  The only reason I could think of is that perhaps we did not used to have the VbPublicKey structure to tell us the size of the key data -- so we would just assume the maximum size (0x1000).\n\nWell, maybe I\u0027m missing some background here.  Do you know, Julius?  Or should I ask Randall?\n\nRegardless, the different routes here are:\n\n(1) Stick with previous model: Read the header first, get the \"real size\", and then read again to get the key.\n(2) Read all of the 0x1000 bytes from flash that the GBB header specifies, and then figure out how much of that we actually need based off of the key header.\n(3) Read all of the 0x1000 bytes that the GBB header specifies, and just return that data, regardless of all the 0\u0027s at the end.",
      "parentUuid": "e96c0343_47d897c3",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2b9c1f1_da65ccda",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2019-04-26T20:47:57Z",
      "side": 1,
      "message": "See my comment on... where was it... idk, somewhere else: I don\u0027t think there\u0027s a need to cache any of these, since the only time we need them more than once is in display use cases (where speed isn\u0027t critical). I\u0027d just always load them on demand. Let\u0027s keep it simple.",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2034a3c_d928181b",
        "filename": "firmware/lib/region-init.c",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 1126709
      },
      "writtenOn": "2019-04-29T04:31:23Z",
      "side": 1,
      "message": "This does raise a question -- if we are guaranteed to have DRAM up by the time we get to kernel verification stage, why do we even need a (larger) workbuf?  Can\u0027t we just use malloc/free?",
      "parentUuid": "e2b9c1f1_da65ccda",
      "revId": "9ae58f7f06172084818dbc2c0135d128717eef38",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}