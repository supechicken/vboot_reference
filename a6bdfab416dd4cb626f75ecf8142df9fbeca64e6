{
  "comments": [
    {
      "key": {
        "uuid": "3a9dd04f_56fb6d37",
        "filename": "firmware/include/tss_constants.h",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1135824
      },
      "writtenOn": "2018-03-23T09:16:53Z",
      "side": 1,
      "message": "What is the expectation here? Developers wanting to check for specific errors codes in downstream code to go in and add mapping code as needed?",
      "range": {
        "startLine": 30,
        "startChar": 23,
        "endLine": 30,
        "endChar": 37
      },
      "revId": "a6bdfab416dd4cb626f75ecf8142df9fbeca64e6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7bcc2b28_287430cb",
        "filename": "firmware/include/tss_constants.h",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1152319
      },
      "writtenOn": "2018-03-23T16:06:48Z",
      "side": 1,
      "message": "No, the idea is that tlcl itself does the mapping when necessary. See example in TlclRead in tpm2_lite/tlcl.c: 0x28b (RC_FMT1 | TPM_RC_HANDLE | TPM_RC_2) from TPM2_NV_Read -\u003e TPM_E_BADINDEX, since places like RollbackFwmpRead() in vboot_reference/firmware/lib/rollback_index.c treat that code in a special way. technically, there\u0027s no single value that says \"BADINDEX\" in TPM2 (depending on which handle it is in a command we\u0027ll have a different RC_HANDLE variation - I haven\u0027t checked if we are ever not handle 2 in other commands), so do this mapping to a single special code in the places where it matters makes sense to me.\n\nIt\u0027s fortunate that TPM2 result codes are designed to avoid collisions with TPM1.2 codes, so we will not get 0x00..02 (BADINDEX) from a spec-compliant TPM2 chip. For TPM2, this result code can be generated only by the tlcl itself, similar to \"vboot local\" codes aabove in this header.\n\nThere is a separate question of \n - converting literal 0x28b to something more meaningful.\n - documenting which special codes are expected from which functions. I went through the firmware code and see that we have this special treatment for TPM_E_BADINDEX, TPM_E_INVALID_POSTINIT, TPM_E_MAXNVWRITES, TPM_E_NEEDS_SELFTEST, TPM_E_DOING_SELFTEST.\n\nBut that\u0027s a topic for a separate cleanup.",
      "parentUuid": "3a9dd04f_56fb6d37",
      "range": {
        "startLine": 30,
        "startChar": 23,
        "endLine": 30,
        "endChar": 37
      },
      "revId": "a6bdfab416dd4cb626f75ecf8142df9fbeca64e6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58c545a8_b2193698",
        "filename": "firmware/include/tss_constants.h",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1135824
      },
      "writtenOn": "2018-03-23T16:26:08Z",
      "side": 1,
      "message": "So that means whoever writes code that relies on one of the error codes below for a certain function where the code wasn\u0027t \"relevant\" before, that code would become a new \"relevant\" error code and the engineer would have to take care of adding the mapping code?\n\nMy main worry here is that it becomes pretty unclear what codes are legit to check for in consuming code, and which can cause issues (such as TPM 2.0 not translating them). In an ideal world, we\u0027d document for each function which  error situations generate a well defined error code (across both TPM 1.2 and 2.0). And these well-behaved error codes would ideally be different from the TPM-generated ones. And we\u0027d further not export declarations of half-supported codes in the headers (i.e. we\u0027d only export vboot local codes and both TPM 1.2 and TPM 2.0 would map to the supported ones).\n\nMy original question was whether you\u0027re intending to make an effort to get into a predictable state or if the situation is going to be best effort (i.e. developers working on consuming code are expected to go in and fix up error handling for error situations they care about).\n\nNote that at this point I\u0027m just trying to understand the intention, I haven\u0027t made up my mind what I consider acceptable or not.",
      "parentUuid": "7bcc2b28_287430cb",
      "range": {
        "startLine": 30,
        "startChar": 23,
        "endLine": 30,
        "endChar": 37
      },
      "revId": "a6bdfab416dd4cb626f75ecf8142df9fbeca64e6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85f71354_758b2b44",
        "filename": "firmware/include/tss_constants.h",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1000039
      },
      "writtenOn": "2018-03-23T16:48:08Z",
      "side": 1,
      "message": "Doesn\u0027t this patch just consolidate TPM_E definitions without changing them?",
      "parentUuid": "58c545a8_b2193698",
      "range": {
        "startLine": 30,
        "startChar": 23,
        "endLine": 30,
        "endChar": 37
      },
      "revId": "a6bdfab416dd4cb626f75ecf8142df9fbeca64e6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6461ad2_626a7369",
        "filename": "firmware/include/tss_constants.h",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1135824
      },
      "writtenOn": "2018-03-23T16:54:20Z",
      "side": 1,
      "message": "Previously, if you compiled on a TPM 2 board (i.e. with TPM2_MODE defined), you wouldn\u0027t get the definition for e.g. TPM_E_AREA_LOCKED. With this patch you get that declaration even for TPM 2.0, so you might be inclined to rely on that error code to detect the situation of locked NVRAM spaces only to find out after debugging that the TPM 2.0 boards never generate that code...\n\nAgain, I\u0027m not saying it\u0027s terrible, but certainly not the ideal behavior from an API perspective :-)",
      "parentUuid": "85f71354_758b2b44",
      "range": {
        "startLine": 30,
        "startChar": 23,
        "endLine": 30,
        "endChar": 37
      },
      "revId": "a6bdfab416dd4cb626f75ecf8142df9fbeca64e6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1d1c5cac_9e88e45b",
        "filename": "firmware/include/tss_constants.h",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1152319
      },
      "writtenOn": "2018-03-23T17:28:06Z",
      "side": 1,
      "message": "\u003e Doesn\u0027t this patch just consolidate TPM_E definitions without changing them?\n\nYes, that\u0027s the idea. The context is that we abandon the plan to come up with separate definitions for TPM_E for TPM2 in the future, and instead do the mapping in the future.\n\n\u003e With this patch you get that declaration even for TPM 2.0, so you might be inclined to rely on that error code to detect the situation of locked NVRAM spaces only to find out after debugging that the TPM 2.0 boards never generate that code...\n\nYes, that\u0027s why we need to document the Tlcl API - which \u0027special\u0027 codes are expected from which function. (1) currently it doesn\u0027t even matter what\u0027s defined in this .h, the callers can have their own header files that defines these errors for them and expect them w/o thinking, (2) TPM_E_AREA_LOCKED is not treated specially by any of the callers, that means it likely doesn\u0027t even belong in tpm1.2-specific header, will need to be removed from this header, and not explicitly checked for by tests, since it\u0027s not a part of the API contract. The contract should be as minimal as actually needed.",
      "parentUuid": "c6461ad2_626a7369",
      "range": {
        "startLine": 30,
        "startChar": 23,
        "endLine": 30,
        "endChar": 37
      },
      "revId": "a6bdfab416dd4cb626f75ecf8142df9fbeca64e6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}