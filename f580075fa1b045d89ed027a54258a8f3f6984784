{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c72ad83c_f549802e",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-05-24T02:01:19Z",
      "side": 1,
      "message": "If the autoupdate knows what it is doing (since it gave the update mode as \u0027deferupdate\u0027), why don\u0027t we just leave the logic there, and skip the UUID thing?\n\nI really don\u0027t want to rely on \"parse stdout\" - that usually leads to bugs and issues.",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f5bdafe_5f576641",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2022-05-24T02:45:54Z",
      "side": 1,
      "message": "\u003e If the autoupdate knows what it is doing (since it gave the update mode as \u0027deferupdate\u0027), why don\u0027t we just leave the logic there, and skip the UUID thing?\n\nThe autoupdater will know when to initiate a deferred update, but it doesn\u0027t know if there will be a FW update or not since the FW slot switch happens or doesn\u0027t.\n\nWe definitely want to hold back the FW slot switch to not introduce reboot races / recovery screens popping up due to FW/kernel mismatch.\nI tried to split in futility the deferred update into HOLD/APPLY, but loading the image takes too long (noticeable amount of delay), so decided it\u0027s best to simply do APPLY (switch FW slot) during postinstall/autoupdater.\n\nSo, the autoupdater/postinstall will be incharge of updating FW try+try_count once the update should actually be applied, but the fw updater is still responsible for informing the autoupdater the FW slot switch needs to happen.\n\n\u003e I really don\u0027t want to rely on \"parse stdout\" - that usually leads to bugs and issues.\n\nAgree, but parsing for uuid should be fairly resilient.\n\nSome ways to communicate this back I could think of were:\n 1. Set the try count of the inactive FW slot\n 2. Print status w/ uuid + parse\n 3. Return code, but currently is always 0 or 1",
      "parentUuid": "c72ad83c_f549802e",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b259aa55_856fd498",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-05-24T03:45:59Z",
      "side": 1,
      "message": "Understood. Setting the cookies without checking the content sounds wrong to me. Consider the case:\n\n- You applied deferred updates. A is active and B is new.\n- After several reboots, for some reason A is corrupted, so the firmware moved to B.\n- User decides to activate deferred update, and autoupdate sets the engine.\n- User moved from B (new) to A (corrupted, or old).\n\nSo it seems more correct to always only do the firmware update one time when you really want to enable a deferred update. What do you think?\n\nIf autoupdate can\u0027t afford a few minutes for updating firmware, there\u0027s another proposal:\n\n- when doing deferred update, always update the new rw to the inactive slot, even if it looks the same with the active firmware.\n- when enabling the deferred update, autoupdate always sets the cookie to try the other slot.",
      "parentUuid": "1f5bdafe_5f576641",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6cad21b2_bad49c78",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-05-24T03:49:36Z",
      "side": 1,
      "message": "the later one is actually very simple:\n\nchange the `if (!cfg-\u003eforce_update)` to `if (!cfg-\u003eforce_update \u0026\u0026 ![is_deferred_update])`.",
      "parentUuid": "b259aa55_856fd498",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3654cc1a_e4580b58",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2022-05-24T04:20:24Z",
      "side": 1,
      "message": "I do like the later \"simpler\" approach, but are increases in writes tolerable/okay to firmware?\n\nIt means that every OS update now will flipflop between A/B whether the firmware are the same/new. (For defer updates)\n\nOtherwise, the current implementation isn\u0027t \"Setting the cookies\" without checking.\nOnce the new FW is written to the inactive slot, the autoupdater will keep track of which is the \"next\" target slot + set the try_next/try_count correctly if it isn\u0027t already the active. (Hence less writes)\n\nWDYT? I\u0027ll defer the final decision to you as owner!",
      "parentUuid": "6cad21b2_bad49c78",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39308c41_0a3ea8fa",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-05-24T05:56:58Z",
      "side": 1,
      "message": "\u003e increases in writes\n\nWe\u0027re only increasing one time for the initial update (from different version). Once A/B are both the right firmware, even futility requested to write, flashrom will figure out there\u0027s no difference and skip the erase-write cycles.\n\n\u003e will flipflop\n\nYes it is, but I\u0027d assume that is fine.\n\n\u003e the autoupdater will keep track of which is the \"next\" target slot \n\nThen we\u0027ll spread the logic of fw update cookies to more difference code base, which sounds even worse IMHO. Probably easier to keep autoupdate handle OS payloads, and leave the firmware stuff all in the futility, with some simple rules.",
      "parentUuid": "3654cc1a_e4580b58",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0eeccc4_01f90965",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2022-05-24T06:16:34Z",
      "side": 1,
      "message": "\u003e \u003e increases in writes\n\u003e \n\u003e We\u0027re only increasing one time for the initial update (from different version). Once A/B are both the right firmware, even futility requested to write, flashrom will figure out there\u0027s no difference and skip the erase-write cycles.\n\nSurprised to hear that flashrom can figure these out..\nTo step through an example:\n IF FW/A is 1.0 and FW/B is 2.0 (active)\n Update FW/A to 2.0, but keep FW/B as (active)\n Set active to FW/A + boot into it.\n On another OS update, writes using flashrom to copy FW/A into FW/B will be \"no-op\"\n IIUC, correct?\n\n\u003e \n\u003e \u003e will flipflop\n\u003e \n\u003e Yes it is, but I\u0027d assume that is fine.\n\nAck.\n\n\u003e \n\u003e \u003e the autoupdater will keep track of which is the \"next\" target slot \n\u003e \n\u003e Then we\u0027ll spread the logic of fw update cookies to more difference code base, which sounds even worse IMHO. Probably easier to keep autoupdate handle OS payloads, and leave the firmware stuff all in the futility, with some simple rules.\n\nUpdating fw cookies seems more straight forward + easier to manage this way rather than piping it from top level all the way down to bottom. We can keep logic all in futility as desired.\n\nNow with logic all handled in futility, autoupdater/postinstall will pipe it down by different calls into futility w/ deferred update HOLD + APPLY.\n\nHOLD in futility will: *always* update RW FW but keep cookies on self target.\nAPPLY in futility will: *always* set cookies to the update target.\n\nHOLD in postinstall will: *always* hold partition update -\u003e call futility HOLD\nAPPLY in postinstall will: *always* update partition -\u003e call futility APPLY\n\nThe deferred updates interface in both futility + postinstall will revolve around HOLD/APPLY actions.\n\nDoes that SGTY?\n\nThanks Hung-Te",
      "parentUuid": "39308c41_0a3ea8fa",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc2c0533_4909163b",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-05-24T07:16:17Z",
      "side": 1,
      "message": "\u003e Surprised to hear that flashrom can figure these out..\n\nflashrom always does read + compare + (if different) erase + write. That\u0027s required for performing partial updates.\n\n\u003e To step through an example:\n\u003e On another OS update, writes using flashrom to copy FW/A into FW/B will be \"no-op\"\n IIUC, correct?\n \nSome devices have firmware with position dependent code so FW/A and FW/B in the same version are actually different.\n\nIn your example we can say:\n\nOn another OS update, writes using flashrom to update either FW/A or FW/B to 2.0 will both be \"no-op\" (only read, no write).\n\n\u003e Does that SGTY?\n\nBasically sounds good; but then are you going to introduce new modes for for futility to \"only apply, no touch RW\"? or you\u0027ll rely on the flashrom trick to perform a mode\u003dautoupdate call?\n\n(note: flashrom won\u0027t write, but it\u0027ll still read - and that may take a few seconds)",
      "parentUuid": "a0eeccc4_01f90965",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "830fe145_f3f042ed",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1007,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2022-05-24T07:24:22Z",
      "side": 1,
      "message": "We shouldn\u0027t want delays to kick in during APPLY, so implemented as discussed above.\n\nHOLD + APPLY method in futility exposed.\n\nWill test this more out tomorrow. Thanks for the indepth reviews + discussion Hung-Te!",
      "parentUuid": "fc2c0533_4909163b",
      "range": {
        "startLine": 1002,
        "startChar": 0,
        "endLine": 1007,
        "endChar": 16
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "459fc092_be24de0d",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1012,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-05-24T02:01:19Z",
      "side": 1,
      "message": "why can\u0027t we just skip setting cookies?",
      "range": {
        "startLine": 1011,
        "startChar": 0,
        "endLine": 1012,
        "endChar": 50
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72e414a1_d28a117b",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1012,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2022-05-24T02:45:54Z",
      "side": 1,
      "message": "I saw one of your comments about always setting the right cookie.\nGoing along the smae idea, the thought was to do the same for deferred update as we want to make sure the user will keep booting into the current FW+OS pair.",
      "parentUuid": "459fc092_be24de0d",
      "range": {
        "startLine": 1011,
        "startChar": 0,
        "endLine": 1012,
        "endChar": 50
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6bafa298_283004c9",
        "filename": "futility/updater.c",
        "patchSetId": 1
      },
      "lineNbr": 1012,
      "author": {
        "id": 1351160
      },
      "writtenOn": "2022-05-25T03:29:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "72e414a1_d28a117b",
      "range": {
        "startLine": 1011,
        "startChar": 0,
        "endLine": 1012,
        "endChar": 50
      },
      "revId": "f580075fa1b045d89ed027a54258a8f3f6984784",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}