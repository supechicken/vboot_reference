{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1e3f6f66_535055b3",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 854,
      "author": {
        "id": 1541362
      },
      "writtenOn": "2022-09-22T17:28:26Z",
      "side": 1,
      "message": "Returning an error code or boolean (`false` for failure is the ancient google3 convention) is a much more clear way to communicate failure than mutating a field of the input.",
      "range": {
        "startLine": 853,
        "startChar": 3,
        "endLine": 854,
        "endChar": 38
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd360c3e_92247811",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 854,
      "author": {
        "id": 1000039
      },
      "writtenOn": "2022-09-22T18:01:36Z",
      "side": 1,
      "message": "not being able to retrieve the GVD ranges from the file is not an error per se, the code running after this function will continue no matter what the result, so there is no point in returning the error.",
      "parentUuid": "1e3f6f66_535055b3",
      "range": {
        "startLine": 853,
        "startChar": 3,
        "endLine": 854,
        "endChar": 38
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f4ec09d_1a6f4f93",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 854,
      "author": {
        "id": 1541362
      },
      "writtenOn": "2022-09-23T17:58:04Z",
      "side": 1,
      "message": "In that case, I think specifying any meaningful error result in a comment ends up being confusing and puts unnecessary requirements on its behavior in the future. As Julius mentions below, you have to ensure you do it in the right order if it\u0027s an actual error signal. If you\u0027re going to explicitly signal an error at _all_, it should be through a return value.",
      "parentUuid": "fd360c3e_92247811",
      "range": {
        "startLine": 853,
        "startChar": 3,
        "endLine": 854,
        "endChar": 38
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c8f8b58_2cc940fe",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 866,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-09-23T01:17:59Z",
      "side": 1,
      "message": "This needs to be initialized before the `load_ap_firmware()` above, if it\u0027s supposed to be the error signal.",
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd0d4085_c44a4057",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 870,
      "author": {
        "id": 1541362
      },
      "writtenOn": "2022-09-22T17:28:26Z",
      "side": 1,
      "message": "This could invoke undefined behavior, since `gsc_verification_data` requires an alignment of 4 bytes and the `data` field has no alignment requirement. The correct way to do this is to perform a copy:\n\n```\nuint16_t size;\n\nmemcpy(\n    \u0026size,\n    ap_firmware_file.data + ap_firmware_file.ro_gscvd-\u003earea_offset\n      + offsetof(struct gsc_verification_data, size),\n    sizeof(size));\ngvd \u003d malloc(size);\nmemcpy(\n    \u0026gvd,\n    ap_firmware_file.data + ap_firmware_file.ro_gscvd-\u003earea_offset,\n    size);\nassert(gvd !\u003d NULL);\n```\n\nThe copy of this line that was already there is incorrect for the same reason. Another, maybe simpler, option is to instead add `__attribute__((packed))` to `struct gsc_verification_data`, which removes its alignment requirement.",
      "range": {
        "startLine": 869,
        "startChar": 6,
        "endLine": 870,
        "endChar": 10
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0dfa2681_494dc395",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 870,
      "author": {
        "id": 1000039
      },
      "writtenOn": "2022-09-22T18:01:36Z",
      "side": 1,
      "message": "GVC verification data layout guarantees alignment, and its location in the image also guarantees alignement. Nowhere in the code does futility care about this, let\u0027s not start it here.",
      "parentUuid": "dd0d4085_c44a4057",
      "range": {
        "startLine": 869,
        "startChar": 6,
        "endLine": 870,
        "endChar": 10
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2a3559e9_41b8d49d",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 870,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-09-23T01:17:59Z",
      "side": 1,
      "message": "We do unaligned accesses all the time and it\u0027s fine with the architectures we support. Adding `packed` leads to horrible code generation on some architectures so I\u0027d generally avoid it where possible. (Besides, like Vadim said, this is not actually unaligned. The `data` comes from an `mmap()` which is guaranteed to be page-boundary aligned.)",
      "parentUuid": "0dfa2681_494dc395",
      "range": {
        "startLine": 869,
        "startChar": 6,
        "endLine": 870,
        "endChar": 10
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9048aa5_36aadc29",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 870,
      "author": {
        "id": 1541362
      },
      "writtenOn": "2022-09-23T17:58:04Z",
      "side": 1,
      "message": "Yeah, the bad codegen is why I avoid `packed` by default. However, I don\u0027t believe that the `gsc_verification_data` is always aligned: I see no guarantee that `ap_firmware_file.data.area_offset` is divisible by 4, so even though the `data` is aligned, there\u0027s nothing inherently ensuring that the `gsc_verification_data` is other than \"the images usually have it aligned\".\n\nCan you add a check that the `area_offset` is divisible by 4 considering you say that this is required by its location in the image and its layout? It\u0027s not *actually* required if it\u0027s not checked. Or is there some other thing that checks that FMAP area offsets are always aligned by 4?\n\nI really don\u0027t love that we depend on unaligned memory access, but I\u0027ll accept it\u0027s standard practice here. I will still strictly forbid it in Rust ðŸ¤“. As long as the compiler isn\u0027t positive it\u0027s unaligned, there shouldn\u0027t be a serious problem on most architectures - if it were positive it\u0027s unaligned through inlining, that is quite dangerous since the cast to create unaligned pointer is UB on its own and the optimizer would have the freedom to completely remove an \"unreachable\" branch, especially with more aggressive optimizations. Give compiler devs an aneurysm with this One Cool Trick!",
      "parentUuid": "2a3559e9_41b8d49d",
      "range": {
        "startLine": 869,
        "startChar": 6,
        "endLine": 870,
        "endChar": 10
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3f8856b_683cc25b",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 883,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-09-23T01:17:59Z",
      "side": 1,
      "message": "nit: I\u0027d maybe call it \"re-sign\" to clarify that this is the re-signing (as opposed to initial first signing) mode of the tool?",
      "range": {
        "startLine": 883,
        "startChar": 16,
        "endLine": 883,
        "endChar": 20
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd4fb431_c43e1636",
        "filename": "futility/cmd_gscvd.c",
        "patchSetId": 5
      },
      "lineNbr": 883,
      "author": {
        "id": 1541362
      },
      "writtenOn": "2022-09-23T17:58:04Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "a3f8856b_683cc25b",
      "range": {
        "startLine": 883,
        "startChar": 16,
        "endLine": 883,
        "endChar": 20
      },
      "revId": "42782c02649cd3827f1c28330c1bd3ad9d490427",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}