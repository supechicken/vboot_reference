{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b9dda06b_9decb339",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1524007
      },
      "writtenOn": "2025-04-07T16:36:18Z",
      "side": 1,
      "message": "happy to provide owners but I have zero context here and would like someone who knows what\u0027s going on to approve.",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1ff6df2e_90b4eac8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1524007
      },
      "writtenOn": "2025-04-07T18:05:52Z",
      "side": 1,
      "message": "Ok, I have a little more context here. Adding a separate note for thoughts",
      "parentUuid": "b9dda06b_9decb339",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f068d1e5_f81827d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1524007
      },
      "writtenOn": "2025-04-07T18:05:52Z",
      "side": 1,
      "message": "Wanted to tag in @vapier@chromium.org and @jwerner@chromium.org to get thoughts on this implementation.\n\nMike/Julius - the TL;DR here is that the signer modifies lsb-release, so a value in lsb-release that contains the hash of the image is subsequently inaccurate. They\u0027re trying to update that hash to reflect the true image hash.\n\nI\u0027m wondering if you feel good about this logic living here in `sign_official_build.sh` or if it makes more sense to do it in the same place where we modify lsb-release in the signer (http://cs/h/chrome-internal/chromeos/superproject/+/main:crostools/signing_docker/dockerbuild/src/sign_utils.py?l\u003d164).",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "883b6f7e_4a2b2fcf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-04-07T22:23:57Z",
      "side": 1,
      "message": "Hmm... this is the first I ever hear of this entire design. I think it creates a problem in that it adds a new kind of \"signing\" (i.e. tying different components of the update payload together with verification) that\u0027s separate from our main signing, and thus breaks the assumption of \"I can change whatever I want, run `sign_official_build.sh` again, and have a verified image again\". From that perspective, I think the code to fix it up should probably live in `sign_official_build.sh`.\n\nBut I really don\u0027t understand why it is necessary in the first place, and it would be much nicer if we could just avoid that extra complexity in the signing process. As I understand, we want to attest the contents of `/etc/lsb-release` to a server. You guys do that by putting the hash of `/etc/lsb-release` into the kernel command line at build time (which is the part that causes problems here), then you have `chromeos_startup` write that entire command line into PCR13 during early userspace boot, and then the server can request attestation for that PCR and compare it with the contents of `/etc/lsb-release` (and the entire kernel command line) sent to it later on.\n\nWhy is the kernel command line even involved at all in any of this? Why don\u0027t you just have `chromeos_startup` read and hash the `/etc/lsb-release` file from disk directly and just write that into PCR13? Seems like that would have made the whole process simpler and prevent these problems with conflicting verification schemes we have right now altogether. (Also, you wouldn\u0027t have to send the entire kernel command line to the server for attestation then, just the release version parts that you\u0027re interested in. There are other things in there like `root\u003dPARTUUID\u003d...` which is a unique per-unit identifier. Is Privacy okay with sending that for attestation when it\u0027s not really necessary for the design?)",
      "parentUuid": "f068d1e5_f81827d7",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "552192d8_0db63c48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1314760
      },
      "writtenOn": "2025-04-08T10:06:17Z",
      "side": 1,
      "message": "First addressing the kernel command line and per-unit identifier concerns:\n\nMy understanding is that the kernel command line is fixed at signing time, and the kernel command line does not change after signing or at the user\u0027s device. The partition UUID is tied directly to that root filesystem which is immutable, and thus is unique per image (vs unique per-unit). If we use the /etc/lsb-release instead, I believe it is unique per-image as well, thus it\u0027s the same whether it\u0027s /etc/lsb-release or kernel command line. Given that our purpose is version attestation, we\u0027ll need to know the exact version, which is basically the exact image that\u0027s running on the device, I believe we\u0027re not disclosing more information than necessary.",
      "parentUuid": "883b6f7e_4a2b2fcf",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ce3b82f_f7118db4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1314760
      },
      "writtenOn": "2025-04-08T10:19:21Z",
      "side": 1,
      "message": "Next on why in the kernel command line:\n\nFor version attestation, we\u0027ll want to minimize the exploit window during boot process. In the current (stepping stone) design, we\u0027re extending the kernel command line into PCR13 during chromeos-init, which is one of the earliest service to start in ChromeOS boot process. However, there\u0027s still a gap between when the kernel loads and when chromeos-init runs. Should there be any kernel exploit or any vulnerabilities in processes that runs before chromeos-init (such as upstart), then it\u0027s possible to defeat version attestation.\n\nTherefore, the ideal solution to version attestation would be to extend the PCR in the firmware/RW, at the time when the kernel is loaded, such as in vboot or depthcharge. However, /etc/lsb-release is not available at that stage, and the closest thing we\u0027ve that can hold the version information would be the kernel command line. Alternatives include adjusting the format of the kernel block to include version information, which is likely not feasible given the amount of units already out there.\n\nThus, the choice to put it in the kernel command line is so that there\u0027s a path way to more secure version attestation. Note that this was designed a while ago, and previously the addition to the kernel command line lived in src/scripts:\nhttps://chromium-review.googlesource.com/c/chromiumos/platform/crosutils/+/4421695\nIt was only recently that we\u0027re launching the feature and discovered that /etc/lsb-release might be changed at signing time and thus breaking version attestation and therefore ARC Attestation.",
      "parentUuid": "552192d8_0db63c48",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc994971_2c31730a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-04-08T20:51:37Z",
      "side": 1,
      "message": "\u003e The partition UUID is tied directly to that root filesystem which is immutable, and thus is unique per image (vs unique per-unit).\n\nNo, this is not true. The partition UUID is unique per unit and autogenerated from scratch every time `chromeos-install` runs (specifically when `write_gpt.sh` calls `cgpt create`). This is important to not confuse the kernel when you\u0027re booting the same image from internal disk that you just installed from a USB stick and the USB stick is still plugged in.\n\nThe kernel command line is signed and immutable in the kernel partition, yes, but that command line contains placeholders â€” i.e. it will contain the string `root\u003dPARTUUID\u003d%U/PARTNROFF\u003d1`. That `%U` is replaced by the firmware on boot with the actual UUID of the partition. The kernel command line you report from a running system (assuming you\u0027re getting it out of `/proc/cmdline` or something like that, and not out of `futility dump_kernel_config /dev/sda2`?) will contain the actual replaced runtime command line that contains the per-unit identifier.\n\n-------\n\nSo your argument for why it is in the kernel command line is that it doesn\u0027t make sense today, but it will make sense eventually when you move the PCR extension part into firmware? That may have been true two years ago, but how does this fit into the AL plans? We are likely never going to put this into firmware for ChromeOS devices now.\n\nAre we planning to do something similar for AL? (I assume \"ARC attestation\" doesn\u0027t make sense for AL, but I guess we may want to be able to attest the version for other purposes?) What is the equivalent for `lsb-release` there? Are you also going to put it into the kernel command line? On AL we additionally have the concept of bootconfig, so is this PCR going to attest the kernel command line, bootconfig or both?\n\nIf the answer is that we don\u0027t want this on AL (or we\u0027re at least not sure in what form we want it yet, and it would have to be a new design) and you just want to make your existing plan work on ChromeOS devices that have already shipped, I think the better option would be to return to just attesting `/etc/lsb-release` from userspace directly and leaving the kernel command line out of this.",
      "parentUuid": "8ce3b82f_f7118db4",
      "revId": "98a82c749390c127636d321f9c6468fdc22201b5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}