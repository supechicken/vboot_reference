{
  "comments": [
    {
      "key": {
        "uuid": "30e904d0_d92e74fe",
        "filename": "host/arch/arm/lib/crossystem_arch.c",
        "patchSetId": 1
      },
      "lineNbr": 479,
      "author": {
        "id": 1000039
      },
      "writtenOn": "2014-10-08T01:32:52Z",
      "side": 1,
      "message": "just curious - where does the difference between mkbp and flash kick in? Does mosys also look at the device tree?",
      "range": {
        "startLine": 479,
        "startChar": 14,
        "endLine": 479,
        "endChar": 19
      },
      "revId": "cfa4035ec8f9c18e6658a1f3d1337c302d524ae6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10e6c0ff_2ae61fc3",
        "filename": "host/arch/arm/lib/crossystem_arch.c",
        "patchSetId": 1
      },
      "lineNbr": 479,
      "author": {
        "id": 1000253
      },
      "writtenOn": "2014-10-08T18:29:03Z",
      "side": 1,
      "message": "Currently mosys does not rely heavily on the device tree (though it could use it if we want). The difference between mkbp and flash kick in with the low-level access method, and in this case mosys is our abstraction layer.\n\nThe reason I chose this method is because crossystem has a mosys wrapper and mosys has a flashrom wrapper, so the pieces are readily available and fairly simple to use. We could have crossystem handle some or all of this more directly, but that would entail a lot of duplication.",
      "parentUuid": "30e904d0_d92e74fe",
      "revId": "cfa4035ec8f9c18e6658a1f3d1337c302d524ae6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "708d3c44_d745560d",
        "filename": "host/arch/arm/lib/crossystem_arch.c",
        "patchSetId": 1
      },
      "lineNbr": 479,
      "author": {
        "id": 1000039
      },
      "writtenOn": "2014-10-08T18:40:59Z",
      "side": 1,
      "message": "so, you call the same mosys function in both cases (ec and flash based VBNV). How does mosys know what path to take if it does not consult the device tree on its own?",
      "parentUuid": "10e6c0ff_2ae61fc3",
      "revId": "cfa4035ec8f9c18e6658a1f3d1337c302d524ae6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10116099_768f51b9",
        "filename": "host/arch/arm/lib/crossystem_arch.c",
        "patchSetId": 1
      },
      "lineNbr": 479,
      "author": {
        "id": 1000253
      },
      "writtenOn": "2014-10-08T18:51:42Z",
      "side": 1,
      "message": "Those decisions are usually programmed on a per-board basis by setting the appropriate function pointer to a callback in the platform interface (intf-\u003ecb in mosys code). Specifically, here\u0027s how it\u0027s done for storm:\nhttps://chromium-review.googlesource.com/#/c/221349/4/platform/google/storm/storm.c\n\nThe way mosys is designed allows us to swap out these callbacks any way we want without necessarily relying on external information e.g. from ACPI or device tree. So we _could_ have mosys read the device-tree to figure out where to read it from, it just hasn\u0027t been applied that way yet.",
      "parentUuid": "708d3c44_d745560d",
      "revId": "cfa4035ec8f9c18e6658a1f3d1337c302d524ae6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}