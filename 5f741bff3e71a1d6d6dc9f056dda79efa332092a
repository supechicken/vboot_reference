{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ce2fe4d6_62e640f5",
        "filename": "host/arch/x86/lib/crossystem_arch.c",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2023-07-28T02:15:13Z",
      "side": 1,
      "message": "I\u0027m a little worried about the design here. People may not be aware of that and try to get path pointers and not aware of they will be the same.\n\nIMHO we should split this into a several functions:\n\n````\n// return the cached result of the sysfs base\nstatic const char *GetACPISysfsBase(void);\n\n// build the path in an auto-variable, and call ReadFileInt, then return.\nint ReadSysfsFileInt(const char *fname, int *value);\n````\n\nAnd revise the other invocations if it\u0027s used only one time.\n\nThe other approach, given we\u0027ll have only a few fixed names, would be to create a mapping:\n\n````\nenum SYSFS_FILE_NAMES[] \u003d {\n  SYSFS_BINF,\n  SYSFS_CHNV,\n  SYSFS_CHSW,\n  ...\n  SYSFS_MAX,\n}\n\nstatic const char * char SYSFS_PATH_TABLE[2][] \u003d {\n [0] \u003d {\n   [SYSFS_BINF] \u003d ACPI_LEGACY_PATH \"/BINF\",\n   ...\n },\n [1] \u003d {\n   [SYSFS_BINF] \u003d ACPI_BASE_PATH \"/BINF\",\n }\n}\n\nstatic const char *GetACPISysfsPath(enum SYSFS_FILE_NAMES name) {\n  static int base \u003d -1;\n  // try to decide if base \u003d 0 or 1\n  assert(name \u003c SYSFS_MAX);\n  return SYSFS_PATH_TABLE[base][name];\n}\n````",
      "range": {
        "startLine": 109,
        "startChar": 1,
        "endLine": 109,
        "endChar": 23
      },
      "revId": "5f741bff3e71a1d6d6dc9f056dda79efa332092a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad0bfc29_818474e6",
        "filename": "host/arch/x86/lib/crossystem_arch.c",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2023-07-28T02:18:33Z",
      "side": 1,
      "message": "\u003e People may not be aware of that and try to get path pointers and not aware of they will be the same.\n\nTypo here. I meant people try to get two pointers before accessing them, for example if someday we changed the BINF file name, a developer may write:\n\n````\n  const char *legacy_name \u003d GetACPISysfsPath(\"BINF.1\");\n  const char *boot_info_name \u003d GetACPISysfsPath(\"BootInf1\");\n  \n  if (FileExists(legacy_name))\n      boot_info_name \u003d legacy_name;\n  return ReadFileInt(boof_info_name);\n````",
      "parentUuid": "ce2fe4d6_62e640f5",
      "range": {
        "startLine": 109,
        "startChar": 1,
        "endLine": 109,
        "endChar": 23
      },
      "revId": "5f741bff3e71a1d6d6dc9f056dda79efa332092a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "685cfeff_c01b37f3",
        "filename": "host/arch/x86/lib/crossystem_arch.c",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1275795
      },
      "writtenOn": "2023-07-28T03:10:12Z",
      "side": 1,
      "message": "Reasons for adopting the simple implementation:\n- The file names are unlikely to change.  Given that `crossystem` is relatively less active.  I don\u0027t expect it would change (e.g. for getting new sysfs file content).\n- Eventually, we expect to revert the patch and only leave the path GOOG0016.\n\nIMHO, current implementation is intended to be simple and dumb.  If some following patches are using code like:\n\n```\nconst char *legacy_name \u003d GetACPISysfsPath(\"BINF.1\");\nconst char *boot_info_name \u003d GetACPISysfsPath(\"BootInf1\");\n```\n\nIt shouldn\u0027t take too much time to sense the issue.\n\n\n\nBut if you insist, I would try the first approach you mentioned.\n\nWe would have:\nReadSysfsFileInt()\nReadSysfsFileString()\nReadSysfsFileBit()\n...and probably some more helpers.",
      "parentUuid": "ad0bfc29_818474e6",
      "range": {
        "startLine": 109,
        "startChar": 1,
        "endLine": 109,
        "endChar": 23
      },
      "revId": "5f741bff3e71a1d6d6dc9f056dda79efa332092a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a30509be_53417979",
        "filename": "host/arch/x86/lib/crossystem_arch.c",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2023-07-28T03:39:44Z",
      "side": 1,
      "message": "It\u0027s not clear how long it\u0027d take to finish the transition, so I\u0027d rather make sure we have a healthy codebase. \n\nBTW I can be convinced if the other reviewers are happy with your existing implementation :)",
      "parentUuid": "685cfeff_c01b37f3",
      "range": {
        "startLine": 109,
        "startChar": 1,
        "endLine": 109,
        "endChar": 23
      },
      "revId": "5f741bff3e71a1d6d6dc9f056dda79efa332092a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}