{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5ffed444_e48905be",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 2
      },
      "lineNbr": 371,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-07-23T00:01:29Z",
      "side": 1,
      "message": "Actually, I got a bit concerned about this when looking at it again for a test: the goal for vboot here is that `VB2_SD_FLAG_KERNEL_SIGNED` is only set when the image actually fully verified, without any errors, regardless of which mode we\u0027re booting in. Are we sure that `avb_slot_verify()` will always return an error for any verification issue, even when `ALLOW_VERIFICATION_ERROR` is set? I haven\u0027t followed the whole thing but it looks like it\u0027s playing pretty fast and loose with the return status in some cases (e.g. the main loop at the end of `load_and_verify_vbmeta()` will \"continue with the error\", but then if the next iteration of the loop checks a different descriptor that succeeds again, that success may be returned for the whole call).\n\nIdeally AVB would always give us accurate results, but unless we\u0027re really certain of that we should probably be careful here and only set this if we know we were running validation property (i.e. `if (need_verification \u0026\u0026 result \u003d\u003d ...OK)`.",
      "revId": "dbdf50adc5e64b3cc211c116aded1970ef95ca90",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60d564b4_90540379",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 2
      },
      "lineNbr": 371,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-07-23T06:08:58Z",
      "side": 1,
      "message": "I\u0027m fine with changing the condition to what you suggested. However, it should not make any difference in practice, because we don\u0027t check `VB2_SD_FLAG_KERNEL_SIGNED` in dev mode.\n\nIf we\u0027re changing this, we may need to rewrite the `VB2_DEBUG(\"Keyblock valid: %d\\n\", keyblock_valid)` message to avoid confusion.",
      "parentUuid": "5ffed444_e48905be",
      "revId": "dbdf50adc5e64b3cc211c116aded1970ef95ca90",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67191bd5_a9b64b5d",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 2
      },
      "lineNbr": 371,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-07-24T00:33:10Z",
      "side": 1,
      "message": "So this flag is mainly used to determine the result of `crossystem kernkey_vfy`. Which isn\u0027t used by anything other than tests, I think, but just in general if we provide a field like that we should make sure that it can be trusted.\n\n\u003e If we\u0027re changing this, we may need to rewrite the VB2_DEBUG(\"Keyblock valid: %d\\n\", keyblock_valid) message to avoid confusion.\n\nThis is only affecting the Android boot path, I\u0027m only suggesting we should change this here. For ChromeOS we can continue to return `kernkey_vfy?sig` when we know  that we actually had a correctly-signed keyblock.",
      "parentUuid": "60d564b4_90540379",
      "revId": "dbdf50adc5e64b3cc211c116aded1970ef95ca90",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8d8aaf8_ee021565",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 2
      },
      "lineNbr": 371,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-07-24T02:51:42Z",
      "side": 1,
      "message": "\u003e This is only affecting the Android boot path\n\nYes I know. I was just trying to say, with the suggested change, the meaning of `keyblock_valid \u003d\u003d 0` would change from \"invalid\" to \"cannot guarantee validity\" for Android. So we will be changing the meaning of `kernkey_vfy`.\n\nAnd, looking at the avb implementation, `ret \u003d read_persistent_digest` and `ret \u003d avb_add_root_digest_substitution` seem to be the only problem. The results should be assigned to `sub_ret` first, and assigned to `ret` only for the error case.",
      "parentUuid": "67191bd5_a9b64b5d",
      "revId": "dbdf50adc5e64b3cc211c116aded1970ef95ca90",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}