{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5417699d_76b2fce8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-14T09:04:49Z",
      "side": 1,
      "message": "Do you want to implement a macro for conversion, for example\n\n#define PTR_OFFSET(void * p, int offset) (void *)((uintptr_t)(p)+(offset))\n\nSo we don\u0027t need to cast as uint8_t* everywhere?",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "688a43ce_1ad14f7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-04-14T19:03:34Z",
      "side": 1,
      "message": "I disagree with this. All of our firmware repos (including vboot) rely on GCC extensions in many areas (e.g. statement expressions for things like VB2_MAX()), and those extensions provide valuable features that cannot be expressed with ISO standard C at the same level of flexibility. Every platform we target or would reasonably expect to target in the future is built with GCC/clang anyway. I see no reason to blindly purge GCC extensions from the code just for some theoretical goal of being standards compliant -- that doesn\u0027t actually do anything useful for us, it would be an enormous amount of effort to fully finish (in vboot and especially in coreboot), and our code would just be a lot less readable and maintainable for it (e.g. always having to manually confirm that the arguments have no side effects every time you call MAX(), or risk subtle bugs when they aren\u0027t).\n\nIf we\u0027re not going to outlaw all GCC extensions I see no reason to outlaw any one of them. sizeof(void) is a minor extension but still a useful one -- as you can see in this patch, it avoids having to clutter code with unnecessary casts all over where the `uint8_t *` doesn\u0027t actually have anything semantically to do with the data being pointed to and is just cast to make the compiler happy. Personally, I think sizeof(void) being 1 makes perfect sense and is absolutely always the size you\u0027d want and intuitively expect for `void *` arithmetic -- I\u0027m surprised the standards committee doesn\u0027t just adopt it, but then again the standards committee makes many surprising decisions that are detrimental to the majority of practical use cases of the C language today. Thankfully, GCC/clang are there to shield us against at least some of them and I don\u0027t see why we shouldn\u0027t make full use of that wherever we can.",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "394f751c_9846180e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T01:59:56Z",
      "side": 1,
      "message": "I think Yuping started  the change because we just got some feedback on coreboot.org to use macros instead of (void*).\n\nThe Linux kernel just had similar discussion few months ago. https://lkml.org/lkml/2022/2/24/978\n\nMy 2 cents:\n\n1. We shouldn\u0027t turn off the GCC extension.\n2. It is better to prevent using void* arithmetic if there\u0027re better meaningful ways - for example using structure, or if the target is exactly bytes.\n3. If the target variable (after arithmetic) is not a byte, casting to uintptr_t is better than (char *). \n4. It is also true sometimes (void*) is easier to write/read.\n\nSo maybe consider it like goto - use it when that makes sense?",
      "parentUuid": "688a43ce_1ad14f7e",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e7e9eba_63900265",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2022-04-15T02:39:06Z",
      "side": 1,
      "message": "\u003e I think Yuping started the change because we just got some feedback on coreboot.org to use macros instead of (void*).\n\nKind of. In https://review.coreboot.org/c/coreboot/+/56791/9/src/soc/mediatek/common/pcie.c#109, coreboot reviewers seem to be opposed to void pointer arithmetic, even in MTK\u0027s platform code. Since vboot_reference is considered as a standalone project that might be used beyond chromium, fixing that sounds like the right thing to do. For chromium-only repos such as depthcharge, I agree that they can rely on GCC extensions.\n\n\u003e If we\u0027re not going to outlaw all GCC extensions I see no reason to outlaw any one of them.\n\nFair enough. I didn\u0027t know vboot code is already dependent on GCC extensions by that much (like VB2_MAX).\n\n\u003e I see no reason to blindly purge GCC extensions from the code just for some theoretical goal of being standards compliant -- that doesn\u0027t actually do anything useful for us, it would be an enormous amount of effort to fully finish (in vboot and especially in coreboot)\n\nSo, does coreboot already (heavily?) rely on GCC extensions? If so, we could have argued that with those upstream coreboot reviewers against pointer arithmetic.",
      "parentUuid": "394f751c_9846180e",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3e57638_95e42899",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:52:09Z",
      "side": 1,
      "message": "I think we don\u0027t want to blindly remove all pointer-arith, but some can be replaced by vb2_member_of that will be easier to read than pointer+.",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0c975aa_1e2690e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-04-15T04:19:17Z",
      "side": 1,
      "message": "Yeah, different people have different opinions, of course... and some people upstream particularly love to constantly demand certain things in reviews that are obviously not required by the official coreboot coding style and not common practice in the code base (e.g. Paul asking everyone who uses CB:xxxx in a commit message to paste in the whole SHA instead). Whenever I see that I argue the same points with them. I didn\u0027t see this particular case.\n\nI am 100% with Linus in the post Hung-Te linked, I think he makes exactly the right points. `void *` arithmetic makes things easier to read and avoids clutter and unnecessary (potentially confusing) casts in some cases, I see no reason not to use it where it works. Of course there are other cases (e.g. bit masking) where you have to convert to an integer type. At the same type, we should convert every simple address addition to uintptr_t when it\u0027s already a `void *` and the addition works on that just as well.\n\nI can try to kick off a discussion about clarifying this to the coreboot coding style, maybe that will make these discussions easier in the future.\n\n\u003e So, does coreboot already (heavily?) rely on GCC extensions?\n\nYes, of course! Statement expressions (e.g. `MAX()`) are a GCC extension. Zero-length arrays (which you can `sizeof()`, unlike variable-length C99 arrays) are a GCC extension. Everything `__attribute__(())` is a GCC extension. Vararg-macros (at least the nicer, more flexible version we use) are a GCC extension. Compound literals (i.e. the GPIO() macro for most Arm SoCs) are a GCC extension. Inline assembly is a GCC extension. Compiler intrinsics (e.g. __builtin_clz()) are GCC extensions. Trying to build any large scale project with pure `-ansi -pendantic` is madness.",
      "parentUuid": "7e7e9eba_63900265",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0522b894_66a27364",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2022-04-15T05:43:09Z",
      "side": 1,
      "message": "\u003e I can try to kick off a discussion about clarifying this to the coreboot coding style, maybe that will make these discussions easier in the future.\n\nThat will be helpful. Thanks.\n\n\u003e 2. It is better to prevent using void* arithmetic if there\u0027re better meaningful ways - for example using structure, or if the target is exactly bytes.\n\u003e 3. If the target variable (after arithmetic) is not a byte, casting to uintptr_t is better than (char *).\n\nYes, but since this is different from my intention of creating this patch, I\u0027m going to abandon this. Thanks for all your inputs.",
      "parentUuid": "e0c975aa_1e2690e3",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8baae20f_383fe409",
        "filename": "Makefile",
        "patchSetId": 2
      },
      "lineNbr": 134,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:51:06Z",
      "side": 1,
      "message": "no, let\u0027s keep pointer-arith.",
      "range": {
        "startLine": 134,
        "startChar": 37,
        "endLine": 134,
        "endChar": 52
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8162c0e2_0f6e5573",
        "filename": "Makefile",
        "patchSetId": 2
      },
      "lineNbr": 134,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-04-15T04:19:17Z",
      "side": 1,
      "message": "Well, if I understand the GCC manual correctly, this warning does nothing else than warn about `sizeof(void)`. So if we say `void *` arithmetic is fine in certain places, we don\u0027t want it?",
      "parentUuid": "8baae20f_383fe409",
      "range": {
        "startLine": 134,
        "startChar": 37,
        "endLine": 134,
        "endChar": 52
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f03a4bff_1f0bd701",
        "filename": "Makefile",
        "patchSetId": 2
      },
      "lineNbr": 134,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T05:27:08Z",
      "side": 1,
      "message": "The \u0027-Wpointer-arith\u0027 would warn any pointer arithmetic, not just sizeof(void).\n\n```\n int main() {\n   void *p \u003d NULL;\n   p +\u003d 1;\n   return 0;\n }\n```\n \n```\n# gcc -Wpointer-arith test.c\n# test.c:7:5: warning: pointer of type ‘void *’ used in arithmetic [-Wpointer-arith]\n```",
      "parentUuid": "8162c0e2_0f6e5573",
      "range": {
        "startLine": 134,
        "startChar": 37,
        "endLine": 134,
        "endChar": 52
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16d7dc56_90af6c04",
        "filename": "firmware/2lib/2common.c",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "Given the member is not uint8_t, I\u0027d rather use uintptr_t to help people understand that we\u0027re simply doing calculation.",
      "range": {
        "startLine": 108,
        "startChar": 8,
        "endLine": 108,
        "endChar": 35
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d639c52c_2b21b715",
        "filename": "firmware/2lib/2common.c",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-04-15T04:19:17Z",
      "side": 1,
      "message": "I think this is a clear case where there\u0027s nothing wrong with `void *` arithmetic. You\u0027re adding a byte offset to a void pointer, nothing more complicated than that. No reason to cast to integer and back.\n\n(Note that this function mostly exists for when `parent` is _not_ a `void *` in the caller and gets implicitly converted, so that you can add a byte offset to a struct vb2_keyblock or something like that in order to find the keyblock data behind the struct. Using this function on something that\u0027s already a `void *` in the caller is kinda pointless.)",
      "parentUuid": "16d7dc56_90af6c04",
      "range": {
        "startLine": 108,
        "startChar": 8,
        "endLine": 108,
        "endChar": 35
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "774ad6ae_ca9f8ee3",
        "filename": "firmware/2lib/2context.c",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "vb2_member_of(sd, sd-\u003eworkbuf_used) ?",
      "range": {
        "startLine": 16,
        "startChar": 22,
        "endLine": 16,
        "endChar": 55
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "252f98cd_ae27ee83",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "can we replace by\n\n vb2_member_of(sd, sd-\u003egbb_offset) ?",
      "range": {
        "startLine": 37,
        "startChar": 9,
        "endLine": 38,
        "endChar": 1
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d4efe2b_a688b508",
        "filename": "host/lib/extract_vmlinuz.c",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "particular for this (\u003e) I think uintptr_t or intptr_t (depends on what we were trying to check here) is better than (uint8_t*) and (void *).",
      "range": {
        "startLine": 49,
        "startChar": 6,
        "endLine": 49,
        "endChar": 16
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8114bda_2f95e605",
        "filename": "host/lib/fmap.c",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "isn\u0027t this ah \u003d (FmapAreaHeader*)(fmap + 1) given fmap is already FmapHeader?",
      "range": {
        "startLine": 58,
        "startChar": 1,
        "endLine": 58,
        "endChar": 63
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Owners",
        "description": {
          "value": "User with the code owner override approved the change"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:enabled_code-owners"
          }
        },
        "submittabilityExpression": {
          "expressionString": "has:approval_code-owners"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Owners-Override\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:enabled_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:enabled_code-owners"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:approval_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:approval_code-owners"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Owners-Override=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Owners-Override=+1"]}
      },
      "patchSetCommitId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "Submit requirement for the \u0027Code-Review\u0027 label"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1"]}
      },
      "patchSetCommitId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {},
      "overrideExpressionResult": {},
      "patchSetCommitId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "CI or human verified the change"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Verified\u003dMAX AND -label:Verified\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Verified=MAX AND -label:Verified=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Verified=MAX","label:Verified=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1"]}
      },
      "patchSetCommitId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}