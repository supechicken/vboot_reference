{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5417699d_76b2fce8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-14T09:04:49Z",
      "side": 1,
      "message": "Do you want to implement a macro for conversion, for example\n\n#define PTR_OFFSET(void * p, int offset) (void *)((uintptr_t)(p)+(offset))\n\nSo we don\u0027t need to cast as uint8_t* everywhere?",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "688a43ce_1ad14f7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2022-04-14T19:03:34Z",
      "side": 1,
      "message": "I disagree with this. All of our firmware repos (including vboot) rely on GCC extensions in many areas (e.g. statement expressions for things like VB2_MAX()), and those extensions provide valuable features that cannot be expressed with ISO standard C at the same level of flexibility. Every platform we target or would reasonably expect to target in the future is built with GCC/clang anyway. I see no reason to blindly purge GCC extensions from the code just for some theoretical goal of being standards compliant -- that doesn\u0027t actually do anything useful for us, it would be an enormous amount of effort to fully finish (in vboot and especially in coreboot), and our code would just be a lot less readable and maintainable for it (e.g. always having to manually confirm that the arguments have no side effects every time you call MAX(), or risk subtle bugs when they aren\u0027t).\n\nIf we\u0027re not going to outlaw all GCC extensions I see no reason to outlaw any one of them. sizeof(void) is a minor extension but still a useful one -- as you can see in this patch, it avoids having to clutter code with unnecessary casts all over where the `uint8_t *` doesn\u0027t actually have anything semantically to do with the data being pointed to and is just cast to make the compiler happy. Personally, I think sizeof(void) being 1 makes perfect sense and is absolutely always the size you\u0027d want and intuitively expect for `void *` arithmetic -- I\u0027m surprised the standards committee doesn\u0027t just adopt it, but then again the standards committee makes many surprising decisions that are detrimental to the majority of practical use cases of the C language today. Thankfully, GCC/clang are there to shield us against at least some of them and I don\u0027t see why we shouldn\u0027t make full use of that wherever we can.",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "394f751c_9846180e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T01:59:56Z",
      "side": 1,
      "message": "I think Yuping started  the change because we just got some feedback on coreboot.org to use macros instead of (void*).\n\nThe Linux kernel just had similar discussion few months ago. https://lkml.org/lkml/2022/2/24/978\n\nMy 2 cents:\n\n1. We shouldn\u0027t turn off the GCC extension.\n2. It is better to prevent using void* arithmetic if there\u0027re better meaningful ways - for example using structure, or if the target is exactly bytes.\n3. If the target variable (after arithmetic) is not a byte, casting to uintptr_t is better than (char *). \n4. It is also true sometimes (void*) is easier to write/read.\n\nSo maybe consider it like goto - use it when that makes sense?",
      "parentUuid": "688a43ce_1ad14f7e",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e7e9eba_63900265",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2022-04-15T02:39:06Z",
      "side": 1,
      "message": "\u003e I think Yuping started the change because we just got some feedback on coreboot.org to use macros instead of (void*).\n\nKind of. In https://review.coreboot.org/c/coreboot/+/56791/9/src/soc/mediatek/common/pcie.c#109, coreboot reviewers seem to be opposed to void pointer arithmetic, even in MTK\u0027s platform code. Since vboot_reference is considered as a standalone project that might be used beyond chromium, fixing that sounds like the right thing to do. For chromium-only repos such as depthcharge, I agree that they can rely on GCC extensions.\n\n\u003e If we\u0027re not going to outlaw all GCC extensions I see no reason to outlaw any one of them.\n\nFair enough. I didn\u0027t know vboot code is already dependent on GCC extensions by that much (like VB2_MAX).\n\n\u003e I see no reason to blindly purge GCC extensions from the code just for some theoretical goal of being standards compliant -- that doesn\u0027t actually do anything useful for us, it would be an enormous amount of effort to fully finish (in vboot and especially in coreboot)\n\nSo, does coreboot already (heavily?) rely on GCC extensions? If so, we could have argued that with those upstream coreboot reviewers against pointer arithmetic.",
      "parentUuid": "394f751c_9846180e",
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8baae20f_383fe409",
        "filename": "Makefile",
        "patchSetId": 2
      },
      "lineNbr": 134,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:51:06Z",
      "side": 1,
      "message": "no, let\u0027s keep pointer-arith.",
      "range": {
        "startLine": 134,
        "startChar": 37,
        "endLine": 134,
        "endChar": 52
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16d7dc56_90af6c04",
        "filename": "firmware/2lib/2common.c",
        "patchSetId": 2
      },
      "lineNbr": 108,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "Given the member is not uint8_t, I\u0027d rather use uintptr_t to help people understand that we\u0027re simply doing calculation.",
      "range": {
        "startLine": 108,
        "startChar": 8,
        "endLine": 108,
        "endChar": 35
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "774ad6ae_ca9f8ee3",
        "filename": "firmware/2lib/2context.c",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "vb2_member_of(sd, sd-\u003eworkbuf_used) ?",
      "range": {
        "startLine": 16,
        "startChar": 22,
        "endLine": 16,
        "endChar": 55
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "252f98cd_ae27ee83",
        "filename": "firmware/2lib/2misc.c",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "can we replace by\n\n vb2_member_of(sd, sd-\u003egbb_offset) ?",
      "range": {
        "startLine": 37,
        "startChar": 9,
        "endLine": 38,
        "endChar": 1
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d4efe2b_a688b508",
        "filename": "host/lib/extract_vmlinuz.c",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "particular for this (\u003e) I think uintptr_t or intptr_t (depends on what we were trying to check here) is better than (uint8_t*) and (void *).",
      "range": {
        "startLine": 49,
        "startChar": 6,
        "endLine": 49,
        "endChar": 16
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8114bda_2f95e605",
        "filename": "host/lib/fmap.c",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 1000239
      },
      "writtenOn": "2022-04-15T02:50:29Z",
      "side": 1,
      "message": "isn\u0027t this ah \u003d (FmapAreaHeader*)(fmap + 1) given fmap is already FmapHeader?",
      "range": {
        "startLine": 58,
        "startChar": 1,
        "endLine": 58,
        "endChar": 63
      },
      "revId": "d1ac7b7144b66fec5034f55c84fc560445efce34",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}