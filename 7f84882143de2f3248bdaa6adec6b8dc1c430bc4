{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "22be7386_1ed0451b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2024-09-05T13:37:46Z",
      "side": 1,
      "message": "@jwerner@chromium.org I have some concerns about misc partition. I load it here without any validation (it is not described and verified by vbmeta, because its content is created by kernel). There is even no CRC to ensure integrity of the content. What do you think, should we adopt this solution as this is how Android is handling entering recovery (and assume that it is good enough) or should we propose different solution?",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccdfc9b0_fd286cbd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-09-13T20:37:32Z",
      "side": 1,
      "message": "The general idea that boot control metadata is unverified is normal and true for the ChromeOS approach as well. However, I\u0027m not sure having a whole extra disk partition with its own format just for this stuff is a good idea. I thought(?) that the bootloader_message stuff was not a generic Android requirement but only a Pixel implementation detail, and other OEMs are free to implement the same features in other ways?\n\nIf possible, I think it would be better to integrate this into vboot nvdata instead. We would not be using big strings like \"boot-recovery\" there, but just a small bit field to encode the possible values. Whether that\u0027s feasible depends on how much of this bootloader_message block is really used by Android in practice... if it\u0027s only the one thing you\u0027re implementing here (normal, bootonce or recovery), then that should fit into vboot nvdata. The bootloader message file suggests that there are uses for the other fields, e.g. \"recovery\" is supposed to contain a kernel command line for recovery boot... we should check whether that\u0027s actually used that way and how exactly it works (e.g. can we just hardcode that recovery commandline in firmware instead and turn the field into a single on/off bit?). The idea that a whole kernel command line is read out of an unverified partition _does_ sound pretty dangerous to me.",
      "parentUuid": "22be7386_1ed0451b",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e26368e_79d66794",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2024-09-16T16:01:42Z",
      "side": 1,
      "message": "The \"recovery\" field is not a kernel command line but it contains arguments for `recovery` application which is executed in Android recovery. (Some options are [there](https://android.googlesource.com/platform/bootable/recovery/+/refs/heads/main/recovery_main.cpp#349) and rest are [there](https://android.googlesource.com/platform/bootable/recovery/+/refs/heads/main/recovery.cpp#594) with some [comments](https://android.googlesource.com/platform/bootable/recovery/+/refs/heads/main/recovery.cpp#75))\n\nSo if we would like to not use misc partition at all, we need to not only translate commands (bootonce, normal, recovery) but also somehow pass arguments to recovery executable.\n\nI am not sure how much AOSP relies on misc partition presence for other purposes than recovery, but documentation reserves some space on the partition for use by AOSP, [misc layout](https://android.googlesource.com/platform/bootable/recovery/+/refs/heads/main/bootloader_message/include/bootloader_message/bootloader_message.h#25) 32K-64K.\n\nSo we have option a) where we integrate bootcommand and recover arguments into vboot nvdata or b) we will just use misc. Option a) seems to be more robust, but we will need to revisit this code every time when Android recovery gain new option. Also we may miss out on any new Android feature that requires misc partition. Option b) is easier to implement, because this and deptcharge CL is enough to use Android recovery for userdata wipe and other functionalities. For option a) we would need to modify recovery to read its arguments from nvdata.",
      "parentUuid": "ccdfc9b0_fd286cbd",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8808381b_975760ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-09-16T23:43:50Z",
      "side": 1,
      "message": "Okay, yeah, that\u0027s definitely enough for vboot nvdata (at least long string fields like `reason` or `update_package`). And I agree that if the recovery initramfs code is already written to expect this it makes more sense to just use that.\n\nHowever, I still think it may be a good idea to mirror only the bootonce/normal/recovery decision into vboot nvdata, if that\u0027s the only thing relevant to the bootloader. That way we don\u0027t have to find, read and parse an extra partition on every boot. Leave the misc partition to be only relevant to the recovery userspace. What do you think?",
      "parentUuid": "7e26368e_79d66794",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d64a29c_49f2cdc1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-09-16T23:44:19Z",
      "side": 1,
      "message": "edit: \"definitely enough\" was supposed to say \"definitely too much\"",
      "parentUuid": "8808381b_975760ba",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcdce882_69094e37",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2024-09-18T10:02:39Z",
      "side": 1,
      "message": "I traced where `misc` is used and I am afraid that we cannot get away from reading it in the future.\n\nThere is `kcmdlinectrl` tool. At the moment it is used for telling the bootloader to set `kcmdline.binder` property to `rust` or `c` (to select different implementation of binder, it seems to be relevant only during development). The tool was crated at the beginning of 2024, so it is plausible that its capabilities may grow over time.\n\nSecond tool is `mtectrl`. It can control memtag setting through misc partition. It is relevant only on ARM platforms. Bootloader requirements are described [here](https://source.android.com/docs/security/test/memory-safety/bootloader-support)\n\nI am not sure about that, but it is possible that bootloader should revoke key used for userdata encryption on wipe request. For that we would need to parse even more data on misc. (I am not sure if revoking keys would be responsibility of bootloader or Android recovery).\n\nIf we go with mirroring boot command into nvdata, how would we ensure that nvdata and misc stay in sync? And what to do in case of mismatch, Android should check misc content against nvdata and potentially update misc?",
      "parentUuid": "2d64a29c_49f2cdc1",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c52c67a6_78c16ca4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-09-18T20:54:10Z",
      "side": 1,
      "message": "How exactly does this kcmdlinectrl work and what exactly does it do? Does it just write some arbitrary kernel command line options to the misc partition and then the bootloader appends those to the normal command line? That would seem like a huge security problem.\n\nmtectrl looks to be to control some memory tagging experiment, we hopefully don\u0027t need to worry about that for now.\n\nWe expect that the keys for userdata encryption will be tied to the TPM on AL, and will be wiped via TPM owner clear, same as it used to work on Chromebooks.\n\nI was hoping that all accesses to the misc partition from the OS would go through some HAL interface or something that we could override with our own implementation in our vendor partition. Is that not how it works? If there\u0027s no good way to intercept what sets this from the core Android code framework that we don\u0027t control then I agree it may not be worth trying to do something different here.",
      "parentUuid": "fcdce882_69094e37",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "116f576b_4e9a435e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2024-09-18T21:41:03Z",
      "side": 1,
      "message": "kcmdlinectrl sets one bit in `struct misc_kcmdline_message` (this is part of system space on misc) and bootloader checks value of that bit and append predefined property to kernel cmdline. So there is no arbitrary value just added to cmdline and this shouldn\u0027t be huge security risk.\n\nAll accesses to the misc partition should go through `misctrl` binary which (AFAIK) is part of AOSP. This tool is accessing block device that has mount point `/misc` in fstab. I was thinking about creating fake device in vendor kernel module which would be the proxy to real misc partition, but it feels more like a hack then a solution. Other solutions probably require modifying `misctrl`.",
      "parentUuid": "c52c67a6_78c16ca4",
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84670a7c_28ff2eb1",
        "filename": "firmware/2lib/2load_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 492,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2024-09-10T12:54:55Z",
      "side": 1,
      "message": "Can you use definition of [BCB as a struct here](https://android.googlesource.com/platform/bootable/recovery/+/refs/heads/main/bootloader_message/include/bootloader_message/bootloader_message.h#67)? It would make code easier to understand. (add struct packing just for safety)",
      "range": {
        "startLine": 492,
        "startChar": 1,
        "endLine": 492,
        "endChar": 11
      },
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8d5b36b_906f8362",
        "filename": "firmware/2lib/2load_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 492,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2024-09-10T16:33:31Z",
      "side": 1,
      "message": "Done, please take a look if it can be defined here, since it is not used in any other place.",
      "parentUuid": "84670a7c_28ff2eb1",
      "range": {
        "startLine": 492,
        "startChar": 1,
        "endLine": 492,
        "endChar": 11
      },
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a4df8fa7_490646ab",
        "filename": "firmware/2lib/2load_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 492,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2024-09-11T14:02:11Z",
      "side": 1,
      "message": "I think it\u0027s fine. It is not required to be exposed in any way.",
      "parentUuid": "b8d5b36b_906f8362",
      "range": {
        "startLine": 492,
        "startChar": 1,
        "endLine": 492,
        "endChar": 11
      },
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c62c7811_2bea8131",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 3
      },
      "lineNbr": 604,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2024-09-10T12:54:55Z",
      "side": 1,
      "message": "`/* Android BCB commands */`",
      "range": {
        "startLine": 604,
        "startChar": 3,
        "endLine": 604,
        "endChar": 22
      },
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17105b32_ec57efa4",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 3
      },
      "lineNbr": 604,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2024-09-10T16:33:31Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c62c7811_2bea8131",
      "range": {
        "startLine": 604,
        "startChar": 3,
        "endLine": 604,
        "endChar": 22
      },
      "revId": "7f84882143de2f3248bdaa6adec6b8dc1c430bc4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}