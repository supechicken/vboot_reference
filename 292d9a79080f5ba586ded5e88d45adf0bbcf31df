{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad82e71_f5d052ff",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 55,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "There are 3 basic boot modes: normal, dev, recovery. You cannot cover them with a boolean value.",
      "range": {
        "startLine": 55,
        "startChar": 65,
        "endLine": 55,
        "endChar": 81
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e47f354_238991b9",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 55,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "I\u0027m confused by this statement - normal/dev mode have to do with loading a modified/unverified OS, while IIUC recovery mode is it\u0027s own thing. The only two actual \"boot\" modes are normal and recovery as far as the bootloader is concerned - covered in vb2ex_get_android_bootmode?",
      "parentUuid": "5ad82e71_f5d052ff",
      "range": {
        "startLine": 55,
        "startChar": 65,
        "endLine": 55,
        "endChar": 81
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70aefb70_8619cbfb",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 55,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T15:14:18Z",
      "side": 1,
      "message": "\u003e I\u0027m confused by this statement - normal/dev mode have to do with loading a modified/unverified OS, while IIUC recovery mode is it\u0027s own thing\n\nRecovery mode in vboot is not related to the OS recovery mode. vboot\u0027s recovery is staying in the RO (Read-Only) firmware version. There we can run either the ChromeOS-type recovery image or we can boot ChromeOS testimage. AFAIK for now Android is not supported in this mode. AL recovery is done through a specially prepared image.\n\n\u003e The only two actual \"boot\" modes are normal and recovery as far as the bootloader is concerned - covered in vb2ex_get_android_bootmode?\n\nThis is true for Android OS, but not the AL Firmware. \n\n---\n\nI got confused by the `dev_mode_transitioning` and `current_dev_mode` names. This actually describes changes between verified vs unverified OS which is not equal to transitioning between dev and normal modes (PTAL: `vb2_need_kernel_verification()`). I think that changing the name from `PREVIOUS_BOOT_DEV_MODE` to something like `KERNEL_VERIFICATION_PREVIOUS_BOOT` would make the intent clearer.",
      "parentUuid": "8e47f354_238991b9",
      "range": {
        "startLine": 55,
        "startChar": 65,
        "endLine": 55,
        "endChar": 81
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e826a913_2a365f34",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 55,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-12T16:20:30Z",
      "side": 1,
      "message": "I see that kernel verification can be skipped even if were not in dev mode - what we care about in this case is the unlocked bootloader status which IIUC is \u003d\u003d to \"androidboot.verifiedbootstate\u003dorange\". I\u0027ve changed the name to be KERNEL_VERIFICATION_PREVIOUS_BOOT to match this closely",
      "parentUuid": "70aefb70_8619cbfb",
      "range": {
        "startLine": 55,
        "startChar": 65,
        "endLine": 55,
        "endChar": 81
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a92f5ca1_bf81582d",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 55,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-15T08:38:26Z",
      "side": 1,
      "message": "\u003e I see that kernel verification can be skipped even if were not in dev mod\n\nThat\u0027s not true. In non-dev mode (norma/recovery modes), kernel verification is always needed. In dev mode, kernel verification *may* be enabled (by either FWMP or NVDATA flag).\n\nI think checking dev switch (instead of `vb2_need_kernel_verification`) makes better sense. My interpretation of `vb2_need_kernel_verification` is that, \"unlocked mode\" is still equivalent to \"dev mode\", but our bootloader just provides extra flags to make dev mode safer.\n\nAlso, [C-1-9] requires physical confirmation for changing bootloader to unlocked mode, and we implement that for normal-to-dev transition only. We don\u0027t require physical confirmation for toggling `VB2_NV_DEV_BOOT_SIGNED_ONLY` in dev mode (which in turn toggles the result of `vb2_need_kernel_verification`). \n\n@jwerner@chromium.org",
      "parentUuid": "e826a913_2a365f34",
      "range": {
        "startLine": 55,
        "startChar": 65,
        "endLine": 55,
        "endChar": 81
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e66a79a3_d3888d90",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 58,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "This function is complicating the logic here. There is only a single use of it, so it can be removed and comment can be moved to the place of the usage.",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 58,
        "endChar": 1
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "100310b8_fa139808",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 58,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e66a79a3_d3888d90",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 58,
        "endChar": 1
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09fbcb5d_7e92af79",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 379,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "style: comment not matching requirements. Please use one of the styles below:\n```\n/* Short multiline\n   comment */\n\n/* \n * Long\n * multiline\n * comment\n */\n ```",
      "range": {
        "startLine": 378,
        "startChar": 1,
        "endLine": 379,
        "endChar": 43
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "34cb8666_613b5962",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 379,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "09fbcb5d_7e92af79",
      "range": {
        "startLine": 378,
        "startChar": 1,
        "endLine": 379,
        "endChar": 43
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2a331e0_ea3350c3",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "Kernel verification does not imply dev mode. There is `vb2_check_dev_switch()` to check for the real dev mode including the GBB Dev mode flag.",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b48bcbf_51799573",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-09-11T10:11:56Z",
      "side": 1,
      "message": "I think that the best solution is to used `vb2_check_dev_swith()` to verify that transition happened and pass that info up in `vb2_shared_data-\u003eflags`. @yupingso@chromium.org @jwerner@chromium.org do we have other mechanisms to detect dev\u003c-\u003enormal transition?",
      "parentUuid": "b2a331e0_ea3350c3",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b93067c9_f98e2e39",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "I already tried to use the vb2_check_dev_switch to check this, @jwerner@chromium.org informed me that modifying/using that function is *almost* impossible since it is in RO firmware. Since the last flag it modifies is VB2_SECDATA_FIRMWARE_FLAG_LAST_BOOT_DEVELOPER (which incorporates all the above concerns), I think that would be better to determine \"Are we in dev mode on the current boot?\"",
      "parentUuid": "2b48bcbf_51799573",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53a05caa_77ebaaf6",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-12T09:34:43Z",
      "side": 1,
      "message": "Sorry, but I think there\u0027s a major design problem here (with either `VB2_SECDATA_FIRMWARE_FLAG_LAST_BOOT_DEVELOPER` or `vb2_check_dev_switch`). As the powerwash for dev/norm transition is a security feature, the implementation must take edge cases into account. For example, after enabling dev mode, the user may reboot the device at any time before the powerwash. I think the only way to do this correctly is to clear the `FLAG` (flag indicating powerwash needed) only after the powerwash, no matter where the `FLAG` is stored. That implies that the `FLAG` must be cleared outside firmware.\n\nThat\u0027s also how powerwash is done in ChromeOS, where the `FLAG` is a file `/mnt/stateful_partition/.developer_mode`, maintained by `clobber-state` and checked by [`startup`](https://source.corp.google.com/h/chrome-internal/chromeos/superproject/+/main:src/platform2/init/startup/chromeos_startup.cc;l\u003d518;drc\u003d3358d3d5811c7ceb6f847d177a9eee048d493fe6) for powerwash decision.\n\n@thomascedeno@google.com Has anyone looked into how we can implement a similar mechanism in Android? One possible solution is to have a custom script for AL (with logic similar to `startup`), instead of directly calling `recovery --wipe_data` from `vb2ex_factory_data_reset()`. If that doesn\u0027t work for any reason, I guess we can also check if TPM is owned here in firmware as part of the powerwash condition (in this case \"TPM owned\" is used as the `FLAG`).\n\nIn addition, we also need to consider the use cases of developers and labs (FAFT). If FDR is pretty fast (BTW is the 5-min transition still a requirement for AL?), then that probably isn\u0027t an issue. Otherwise, we\u0027ll need to think about how to skip FDR for those cases (for example by adding a GBB flag to skip FDR, or by having a \"debugging AL image\" similar to ChromeOS test image).",
      "parentUuid": "b93067c9_f98e2e39",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "963832a6_cacd37cd",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-12T14:59:39Z",
      "side": 1,
      "message": "I have spent some time thinking about this exact scenario you describe, and I think this impl fits the behavior of the old /mnt/stateful_partition/.developer_mode.\n\nIf a user reboots during any arbitrary point in the bootup process one of two things retry the powerwash process\n1) If only the VB2_NV_PREVIOUS_BOOT_DEV_MODE has been written, but the system failed to write to the gpt misc partition in vb2ex_factory_data_reset, it will try again over repeated boots\n2) Once the system has successfully written to the gpt misc partition it will continually try to perform FDR and only AFTER it has successfully done so will it clear the commands in the BCB - see the comments in https://source.corp.google.com/h/googleplex-android/platform/superproject/main/+/main:bootable/recovery/recovery.cpp;l\u003d91?q\u003drecovery%20wipe_data\u0026ss\u003dh%2Fgoogleplex-android%2Fplatform%2Fsuperproject%2Fmain%2F%2B%2Frefs%2Fheads%2Fmain.\n\nPerforming FDR on my machine is very fast (i.e. less than 30 seconds) and for lab scenarios if you are running an eng build it doesn\u0027t reset ADB connections so I think he have are bases covered on that front.",
      "parentUuid": "53a05caa_77ebaaf6",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab44ae55_d9893ca5",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-09-15T07:21:18Z",
      "side": 1,
      "message": "I am not quite sure why we cannot change code in RO FW. I think that cannot update RO FW only for the boards which are after the FSI phase and have its own firmware branch.\n\nSo, if using vb2_check_dev_switch() simplifies the code, then such a change should be implemented on `main`. Any alternative implementation that avoids modifying the RO firmware should be done on board specific firmware-xxx branches.",
      "parentUuid": "963832a6_cacd37cd",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b7b6f43_b484241f",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-15T08:38:26Z",
      "side": 1,
      "message": "\u003e I have spent some time thinking about this exact scenario you describe, and I think this impl fits the behavior of the old /mnt/stateful_partition/.developer_mode.\n\nThank you. I didn\u0027t know about \"2)\" mentioned above.\n\n\u003e Performing FDR on my machine is very fast (i.e. less than 30 seconds)\n\nFirmware developers may switch between normal and dev modes quite often, so I\u0027d still prefer saving the 30 seconds for both lab and developers. I\u0027m fine with proceeding with this patch, but can we file a bug to discuss that and leave it as a future work?\n\n\u003e I am not quite sure why we cannot change code in RO FW. I think that cannot update RO FW only for the boards which are after the FSI phase and have its own firmware branch.\n\n+1 to this argument. However the problem here is that, the flag cannot be written back to nvdata *before* `vb2ex_factory_data_reset` is called. Otherwise a reboot between \"flag write\" and `vb2ex_factory_data_reset` will allow the user to bypass FDR. Therefore the solution of passing `vb2_shared_data-\u003eflags` from `vb2_check_dev_swith` to depthcharge wouldn\u0027t work.",
      "parentUuid": "963832a6_cacd37cd",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98a64027_aed9e42e",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-09-15T09:55:51Z",
      "side": 1,
      "message": "yes, I agree, but still we can detect transition at `vb2_check_dev_swith` and set non-volatile variable there, right? That way the whole logic of dev\u003c-\u003enormal mode transition is in one place",
      "parentUuid": "7b7b6f43_b484241f",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8a9bf9f_a98ceb1d",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-15T10:03:49Z",
      "side": 1,
      "message": "\u003e still we can detect transition at `vb2_check_dev_switch` and set non-volatile variable there, right?\n\nHow? `vb2_check_dev_switch` is called from `vb2api_fw_phase1`. After it detects the transition, the new `VB2_SECDATA_FIRMWARE_FLAGS` value will be saved to `ctx-\u003esecdata_firmware` (in memory), which will then be saved back to GSC at the end of verstage (`vboot_save_data` in coreboot/src/security/vboot/vboot_logic.c).\n\nTherefore, now if an abrupt reboot happens (before device boots to depthcharge), the next `vb2_check_dev_switch` after reboot will detect no transition.",
      "parentUuid": "98a64027_aed9e42e",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83d101ea_47013335",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-09-15T10:33:21Z",
      "side": 1,
      "message": "Maybe I complicate things, but if `vb2_check_dev_switch` detects transition it can save it in non-volatile variable, which can be cleared only when `vb2ex_factory_data_reset()` is called. That\u0027s all, am I missing something?\nI just think, that it would be simpler if we could put all transition detection in one place.",
      "parentUuid": "b8a9bf9f_a98ceb1d",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5429010f_a50ef624",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-15T16:11:00Z",
      "side": 1,
      "message": "Yes, you are correct, of course. Sorry, I just missed \"set non-volatile variable\" in your previous comment. I also found an existing `VB2_NV_REQ_WIPEOUT` flag, so I think we can do the following:\n\n- For new Android devices, re-use `VB2_NV_REQ_WIPEOUT`. The flag is set in `vb2_check_dev_switch` and cleared after calling `vb2ex_factory_data_reset`.\n- For launched devices, add a new nvdata flag `VB2_NV_PREV_DEV_BOOT`. In `vb2_load_android`, set `VB2_NV_REQ_WIPEOUT` based on the value of `VB2_NV_PREV_DEV_BOOT`, and then update `VB2_NV_PREV_DEV_BOOT`. Finally, call `vb2ex_factory_data_reset` and clear `VB2_NV_REQ_WIPEOUT`. This slightly complicated flow is just for making it closer to the ToT code.",
      "parentUuid": "83d101ea_47013335",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9dac89e8_93c2dd0e",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-15T18:13:34Z",
      "side": 1,
      "message": "I think it would be fine to re-use `VB2_NV_REQ_WIPEOUT` for checking the dev switch, but since this value is only cleared by the TPM specific code I don\u0027t think we should have vb2ex_factory_data_reset reset it, since clearing of the TPM might not line up 1:1 with clearing disk storage.\n\nIn addition `VB2_NV_REQ_WIPEOUT` is only modified with the  VB2_CONTEXT_FORCE_WIPEOUT_MODE flag, which I\u0027m unfamiliar with when that flag may/may not be enabled.\n\nWhy not just have the approach of setting something like `VB2_NV_DEV_TRANSITION` in vb2_check_dev_switch at the same time \u0027VB2_NV_REQ_WIPEOUT\u0027 would be set, then have it be checked at vb2_load_android so the time they are cleared at would be distinctly separate?\n\nThis is the approach I used in patchset #7 if you want to take a look.",
      "parentUuid": "5429010f_a50ef624",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e87c4fb7_4f110412",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-09-15T23:30:38Z",
      "side": 1,
      "message": "I had already talked to Thomas offline when this patch was first uploaded and I thought(?) we had remained with the understanding that firmware is not a good place to implement this (because of basically the reasons Yu-Ping pointed out). So I\u0027m not quite sure why we are suddenly uploading patch sets for this approach again.\n\nTo clarify for the record here again:\n\n* The actual dev-mode transition happens in RO firmware during early boot. We need to support migrating devices where we cannot modify RO firmware anymore. Therefore, there\u0027s no real way around a solution that imprecisely tracks the dev mode transition independently from later stages with separate state-keeping, even though that\u0027s clunky.\n\n* If we need to do that independent state-keeping anyway, there\u0027s no real reason to do it from RW firmware vs the OS level. This is a notification that the OS needs so it would make more sense for it to just do that itself rather than create another OS\u003c-\u003efirmware interdependency.\n\n* So I think the most straightforward solution here would be that something in early Android userspace compares some local state about dev mode (maybe on the misc partition?) with the state reported by firmware, and triggers the appropriate transition behavior if they mismatch. That\u0027s equivalent to what ChromeOS has been doing all these years. RW firmware doesn\u0027t really need to be involved.",
      "parentUuid": "9dac89e8_93c2dd0e",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41db1f6d_fcc74a38",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-09-16T07:25:37Z",
      "side": 1,
      "message": "\"The actual dev-mode transition happens in RO firmware during early boot. We need to support migrating devices where we cannot modify RO firmware anymore.\"\nBut still we can use that for new boards which are still before FSI, right? For migrating devices (if there will be any) we can use other solution.\n\n\n\"So I think the most straightforward solution here would be that something in early Android userspace compares some local state about dev mode (maybe on the misc partition?)\"\nIf I understand code correctly, FDR requires going into recovery mode. It is much simpler and quicker to force it from FW than go to Android normal mode and then reboot again to recovery mode. @thomascedeno@google.com, can you confirm how it works? I am also not sure if this is a safe solution to allow boot to normal mode when FDR is required.\nWhile we can implement other Android data-wiping mechanisms, should we change the OS for the firmware?",
      "parentUuid": "e87c4fb7_4f110412",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ee32bbf_9041157e",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-16T08:04:34Z",
      "side": 1,
      "message": "\u003e If we need to do that independent state-keeping anyway, there\u0027s no real reason to do it from RW firmware vs the OS level.\n\nMy reason is to keep the implementation of migrating devices closer to new Android devices, and the price is to add a new `VB2_NV_PREV_DEV_BOOT` to old firmware branches, which IMO is acceptable. I\u0027d prefer not making major design decisions due to the even-not-finalized fact that there will be devices migrating to Android. IMO, any design/implementation should be optimized for new devices.",
      "parentUuid": "41db1f6d_fcc74a38",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27892a1c_c35719ca",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-16T14:58:07Z",
      "side": 1,
      "message": "\"This is a notification that the OS needs so it would make more sense for it to just do that itself rather than create another OS\u003c-\u003efirmware interdependency\".\nI’m not quite sure what this is referring to, @jwerner@chromium.org why does the OS need this notification? Back in ChromeOS classic the wiping of stateful partition was done by userspace script clobber_stateful.cc so it made sense there, but to confirm what @bernacki@google.com said FDR will require going into recovery mode so I don’t see how main OS should be involved?\n\nI uploaded this change since there is a way for firmware to keep track of all this state internally without the use of RO firmware changes, but as @yupingso@chromium.org stated the only real drawback from this CL over the ChromeOS approach is the use of an NV bit to track what /mnt/stateful_partition/.developer_mode used to track, but I wasn’t sure how precious nv bit storage is since it’s a record that was extended to 64 bytes back in 2019.",
      "parentUuid": "8ee32bbf_9041157e",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba839cff_cede78a7",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-09-17T00:21:39Z",
      "side": 1,
      "message": "\u003e But still we can use that for new boards which are still before FSI, right? For migrating devices (if there will be any) we can use other solution.\n\nYes, we could, but I don\u0027t think it would really be better to have to maintain two different solutions? If we already have to do something that doesn\u0027t involve RO firmware changes anyway, I think it\u0027s easier to just stick with that across all platforms.\n\n\u003e It is much simpler and quicker to force it from FW than go to Android normal mode and then reboot again to recovery mode.\n\nWhat makes it simpler? In both cases you\u0027re just writing a thing to the misc partition (and `reboot` is one command from userspace)? In terms of code I would expect this to be at most equivalent (or probably simpler in userland because you don\u0027t have to deal with the split between vboot and depthcharge, and other firmware intricacies). I don\u0027t think execution time really matters much for this rare transition use case. (Also, I don\u0027t really understand why this _has_ to be done from recovery mode. Why can\u0027t we just call the code that does the wipe and reinitialize thing from normal early Android userspace?)\n\n\u003e should we change the OS for the firmware?\n\nI think this is really a case of \"should we change the firmware for the OS\"? Firmware is the code that is more security critical, has tighter space constraints and therefore less flexible APIs available, and is harder to update. In general, no feature should be implemented in firmware when it can without notable drawback be just as well implemented at the OS level.\n\n\u003e My reason is to keep the implementation of migrating devices closer to new Android devices, and the price is to add a new VB2_NV_PREV_DEV_BOOT to old firmware branches\n\nSorry, I might have missed what solution you\u0027re proposing? It\u0027s not the same as this latest patch set is implementing, right?\n\nNote that I don\u0027t think there\u0027s much that can be reused about `VB2_NV_REQ_WIPEOUT` for this. That was a solution specifically for devices where a factory reset is requested with an external button. It\u0027s set in `vb2_check_dev_switch()` but the decision isn\u0027t really tied to dev mode.\n\nIf we wanted to build a solution for this that allows changes to RO firmware I still don\u0027t think it would necessarily be that easy, because the actual dev mode transition is detected before we have disk access available. So you would need to have `vb2_check_dev_switch()` store the fact that a transition occurred in some nvdata (or secdata) flag, and then have later depthcharge code clear that flag and have it write commands into the misc partition instead. That\u0027s also a two-step process and doesn\u0027t really seem much less complicated to me than just tracking the thing in the misc partition in the first place.\n\n\u003e why does the OS need this notification\n\nWell, it\u0027s the OS that wants the disk wiped when the dev mode state changes. So I think it\u0027s most natural if the OS does the tracking necessary to do that by itself, since the firmware isn\u0027t really in a better position to do it anyway.\n\n\u003e but I wasn’t sure how precious nv bit storage is\n\nWe could probably spare one more bit, I\u0027m more concerned about finding the solution that creates the smallest long-term maintenance burden.",
      "parentUuid": "27892a1c_c35719ca",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0285607b_2201d8d4",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-17T02:21:58Z",
      "side": 1,
      "message": "\u003e Sorry, I might have missed what solution you\u0027re proposing? It\u0027s not the same as this latest patch set is implementing, right?\n\nOkay, forget about `VB2_NV_REQ_WIPEOUT`. Whether to re-use that is a separate thing.\n\n- For new devices, my solution is to add `VB2_NV_FDR_REQUESTED` flag, set in `vb2_check_dev_switch()` and cleared in `vb2_load_android()` after the `vb2ex_android_factory_data_reset` call. Yes, that\u0027s a two-step process.\n- For migrating devices, we\u0027ll need to add another `VB2_NV_PREV_DEV_BOOT` flag as a workaround for the `vb2_check_dev_switch()` change because RO cannot be modified.\n\nRegarding `VB2_NV_REQ_WIPEOUT` (b/35546035), right now I can\u0027t find any reader of that flag (`wipeout_request`) in the ChromiumOS code base, so that feature seems to be dropped already. That\u0027s why I think we may re-use the flag to save us one bit.",
      "parentUuid": "ba839cff_cede78a7",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ac97d66_b1edbc84",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-17T14:46:22Z",
      "side": 1,
      "message": "“In terms of code I would expect this to be at most equivalent (or probably simpler in userland because you don\u0027t have to deal with the split between vboot and depthcharge, and other firmware intricacies)”.\nIf the userspace solution also stores this in an NV bit instead of a file on the stateful partition then yes it could be comparable, otherwise the logic becomes much more complicated.\n\n“Why can\u0027t we just call the code that does the wipe and reinitialize thing from normal early Android userspace?”\nUnder the hood every method (except for fastboot IIUC) that performs factory reset does it through this method. I.e. if you perform FDR through the settings app it writes a command to the BCB and reboots the device same as this proposed CL.\n\n“In general, no feature should be implemented in firmware when it can without notable drawback be just as well implemented at the OS level.”\nOther than the overhead of having to go through Android FR. I imagine the owners in charge of their corner of Android init would push back on whether the OS should be responsible for this.\n\n“Well, it\u0027s the OS that wants the disk wiped when the dev mode state changes.”\nI’m unsure what you mean by this, while the end effect is on state partitions for the OS, IIUC the only place developer mode can be initialized/uninitialized is in the bootloader sequence through explicit key presses. In Android world a fairly equivalent property “ro.boot.verifiedbootstate” is initialized, tracked in firmware and then passed into the main OS. From the looks of things, it’s actually the firmware that wants the disk wiped, and I imagine for any change in userspace I would have to justify this to the main OS owners.\n\nI would like to proceed with the solution proposed by @yupingso@chromium.org, above, but I\u0027m pretty indifferent on whether we decide to just implement VB2_NV_PREV_DEV_BOOT as the *only* solution to keep things simpler, or just reusing VB2_NV_REQ_WIPEOUT if there truly is no other consumers of the bit.",
      "parentUuid": "0285607b_2201d8d4",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bd1873c_8cac0031",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-09-18T21:40:46Z",
      "side": 1,
      "message": "Let\u0027s refocus from the ideological questions to more practical aspects for a moment: let\u0027s say we implement Yu-Ping\u0027s proposal. That means that any dev mode transition, whether caused by the UI flow or by changing the GBB flag, will result in depthcharge writing the recovery request to the misc partition. Are we sure we actually want that for all edge cases?\n\nConsider testing: I believe FAFT regularly switches back and forth between dev and verified mode in the course of various tests. We don\u0027t want to wait the time for a full disk wipe between all of those transitions, and also they usually have exact expectations about how the system comes back up during each reboot so this extra recovery boot would throw them off. On ChromeOS, I believe this is solved by just never doing a dev mode wipe on test images (I believe that\u0027s the `!DevIsDebugBuild()` check in `chromeos_startup.cc`). Do we have an equivalent on Android? I assume the equivalent to test images is userdebug(?), but would it be correct to generally skip this wipe on userdebug images? Also, this image type is a property of the OS image so it\u0027s not really easily accessible from firmware. How do you solve this with your solution?\n\nConsider factory and RMA use cases: I don\u0027t know what exactly the current plans for AL are, but generally in ChromeOS factories we run most of the installation process in dev mode and then transition back out of it at the end of finalization. On ChromeOS this does not trigger a dev mode wipe afterwards since the internal disk was just freshly reinstalled (and not actually booted because the factory toolkit runs from netboot), so there\u0027s no dev mode flag file. But if we move this into firmware and tie it to the result of `vb2_check_dev_switch()`, it becomes a very strict check that can\u0027t be forged and picks up transitions like this. Will this mean that factories will always need to reboot the device once more after finalization to let a needless disk wipe run through? Or worse, customers seeing this after unboxing? Keeping the state that says whether a disk wipe is needed _on_ the disk makes it easy to reset it with other out-of-band means that already wipe the disk anyway. (Ideally, the design should really be that the booting system can automatically recognize whether the disk is still \"pristine\" and unused and then know that it doesn\u0027t need to wipe anything again. It\u0027s frustrating that Android demands this explicit state keeping and is unable to repair unexpected states automatically in the way ChromeOS was, and that we can\u0027t change that.)",
      "parentUuid": "2ac97d66_b1edbc84",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45bc85f5_486878b4",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 16
      },
      "lineNbr": 380,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-09-19T07:53:07Z",
      "side": 1,
      "message": "\u003e Are we sure we actually want that for all edge cases?\n\nNo we don\u0027t. In one of my comments above, I\u0027ve mentioned the lab use cases. Even if FDR takes less than 30s, I\u0027d still prefer skipping it for FAFT. A trivial solution is to add a GBB flag to skip the FDR. Another solution is to skip FDR for normal-to-DevModeGBB transition (meaning only do FDR for GSC normal-to-dev transition). Yet another solution is to skip FDR for dev-signed keys.\n\nFor developers using a userdebug image, I guess 30-second FDR might be acceptable. For factory/RMA, I have no comment because I\u0027m not familiar with that.\n\nSo, with my proposal, someone will need to design how to handle those edge cases and have the design properly reviewed (from testing, factory and RMA teams). We\u0027ll also need to carefully check if all the edge cases supported in ChromeOS are covered by our new solution.",
      "parentUuid": "0bd1873c_8cac0031",
      "range": {
        "startLine": 380,
        "startChar": 33,
        "endLine": 380,
        "endChar": 50
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8eb43de8_10b19320",
        "filename": "firmware/2lib/2nvstorage.c",
        "patchSetId": 16
      },
      "lineNbr": 357,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "extra space",
      "range": {
        "startLine": 357,
        "startChar": 24,
        "endLine": 357,
        "endChar": 25
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e8cfd33_0c20a470",
        "filename": "firmware/2lib/2nvstorage.c",
        "patchSetId": 16
      },
      "lineNbr": 357,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8eb43de8_10b19320",
      "range": {
        "startLine": 357,
        "startChar": 24,
        "endLine": 357,
        "endChar": 25
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1365ef80_87488c96",
        "filename": "firmware/2lib/2stub.c",
        "patchSetId": 16
      },
      "lineNbr": 60,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "style: indentation (there is a `.clang-format` you can use :) )",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 60,
        "endChar": 21
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b05b9de_e16e0700",
        "filename": "firmware/2lib/2stub.c",
        "patchSetId": 16
      },
      "lineNbr": 60,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1365ef80_87488c96",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 60,
        "endChar": 21
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70a34f91_69842e96",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 16
      },
      "lineNbr": 1126,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "style",
      "range": {
        "startLine": 1125,
        "startChar": 0,
        "endLine": 1126,
        "endChar": 22
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c14877f2_22e287ce",
        "filename": "firmware/2lib/include/2api.h",
        "patchSetId": 16
      },
      "lineNbr": 1126,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "70a34f91_69842e96",
      "range": {
        "startLine": 1125,
        "startChar": 0,
        "endLine": 1126,
        "endChar": 22
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b241bfe1_0a2d42fe",
        "filename": "firmware/2lib/include/2nvstorage.h",
        "patchSetId": 16
      },
      "lineNbr": 132,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "style",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 132,
        "endChar": 3
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8664f749_5dfd9550",
        "filename": "firmware/2lib/include/2nvstorage.h",
        "patchSetId": 16
      },
      "lineNbr": 132,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b241bfe1_0a2d42fe",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 132,
        "endChar": 3
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d24d4cc6_6acfe026",
        "filename": "firmware/2lib/include/2nvstorage_fields.h",
        "patchSetId": 16
      },
      "lineNbr": 91,
      "author": {
        "id": 1512562
      },
      "writtenOn": "2025-09-11T09:51:31Z",
      "side": 1,
      "message": "No longer correct.",
      "range": {
        "startLine": 91,
        "startChar": 0,
        "endLine": 91,
        "endChar": 47
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c52552b_869c1188",
        "filename": "firmware/2lib/include/2nvstorage_fields.h",
        "patchSetId": 16
      },
      "lineNbr": 91,
      "author": {
        "id": 1430007
      },
      "writtenOn": "2025-09-11T14:22:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d24d4cc6_6acfe026",
      "range": {
        "startLine": 91,
        "startChar": 0,
        "endLine": 91,
        "endChar": 47
      },
      "revId": "292d9a79080f5ba586ded5e88d45adf0bbcf31df",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}