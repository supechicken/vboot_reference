{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c3b054cc_b4d3990a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "Note that while this patch is WIP I won\u0027t get email updates if you upload a new version, so you should usually clear the WIP once you want to get reviews.",
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1466aec2_84dbfbc9",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 416,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "I think we should treat this as a 32-bit number, not a 16-bit number, because that\u0027s what we\u0027re storing in `sd-\u003ekernel_version` as well. We\u0027ll only use the lower 16 bits for the time being, but the upper might come in handy for eventualities down the line (like I mentioned on a comment in your doc). Also, for devices migrating from ChromeOS the upper 16 will already be at least 0x0001 anyway.",
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3eafc06_17fa2cce",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 421,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "I am a bit concerned that there is no mechanism from AVB (other than the return code and \"trust that they didn\u0027t miss a case\") to clearly indicate that this field was initialized correctly. I think we should initialize it to some sentinel value like `~(uint64_t)0` before calling `avb_slot_verify()`, and then confirm that it\u0027s not that anymore before we trust it here.",
      "range": {
        "startLine": 421,
        "startChar": 35,
        "endLine": 421,
        "endChar": 64
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "064312ce_e9322483",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 422,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "nit: Let\u0027s put this at the top of the function just because most functions have it there.",
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0e9a129_4e3d3b2a",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 423,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "No, I don\u0027t think there would be any point in doing this. We should use the entire value given to us in the partition (at least as much as fits in our 32 bits), and then make sure that it gets generated to match what we need on the builder side.",
      "range": {
        "startLine": 423,
        "startChar": 20,
        "endLine": 423,
        "endChar": 59
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06364c50_992bae51",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 423,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-10-29T13:51:05Z",
      "side": 1,
      "message": "I am not quite sure I understand the comment. Are you saying that we should get the key version at the build time and pass it into rollback index?",
      "parentUuid": "e0e9a129_4e3d3b2a",
      "range": {
        "startLine": 423,
        "startChar": 20,
        "endLine": 423,
        "endChar": 59
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b60aeea6_c5581c64",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 423,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-11-04T19:06:01Z",
      "side": 1,
      "message": "I am saying that vboot firmware should take 32 bits from the index in vbmeta and compare it with the entire 32 bits from `sd-\u003ekernel_version_secdata`. So this code should just say\n```\n*kernel_version \u003d (uint32_t)verify_data-\u003erollback_indexes[0];\n```\nOn the build side, where you\u0027re doing `BOARD_AVB_ROLLBACK_INDEX :\u003d $(shell echo $$(( ( $$(date ...) - $$(date ...) ) / 86400 )))`, you should instead be doing something like `$$(( ( $$(date ...) - $$(date ...) ) / 86400 + (3 \u003c\u003c 16))))`. (Whether the hardcoded number there should be 3 or something else depends on the highest kernel key version that we\u0027ve ever had on any of the devices that will migrate to AL, I haven\u0027t checked what exactly that is. For new boards the version always starts at 1, and most never have an increase in their lifetime. I doubt that there\u0027s ever been a board with more than two key bumps so 3 sounds like a safe default for now. Figuring out exactly is pretty cumbersome, unfortunately, you\u0027d either have to work with one of the croskeymanagers@ who have access to the raw keyset files, or you need to download the current signed recovery image for each board and check it with `futility`.)",
      "parentUuid": "06364c50_992bae51",
      "range": {
        "startLine": 423,
        "startChar": 20,
        "endLine": 423,
        "endChar": 59
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20154704_cc587b31",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 423,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-11-05T14:52:29Z",
      "side": 1,
      "message": "But this solution is really confusing for someone with no knowledge about vboot internals. Basically, we just use some artificial value just to make vboot work with ChromeOS requirements, instead of modifying it to work with Android. I think that it would be much cleaner to just reuse the value from secdata as I did in the patch. I know that we should keep FW simply and move changes out of it, but in this particular case I think it would make code harder to understand. Unless I miss some obvious security flow :)",
      "parentUuid": "b60aeea6_c5581c64",
      "range": {
        "startLine": 423,
        "startChar": 20,
        "endLine": 423,
        "endChar": 59
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43631cbd_f38a4fd4",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 423,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-11-06T21:51:22Z",
      "side": 1,
      "message": "Sorry, but I feel like the solution you\u0027re proposing is a hack to accommodate the situation of migrated devices that I don\u0027t want to continue carrying forever. It makes no sense to have a 32-bit rollback counter in the TPM but then only ever use the lower 16 of it and have the upper 16 just stay at whatever value they\u0027re at without having any impact at all on the actual boot decision. 10 years from now when there are no more migrated devices, all our new AL devices would still be doing that and there would be no discernible point to it.\n\nI think the solution that I\u0027m proposing is compatible with migrated devices but not entirely useless afterwards. I think it makes sense to consider the upper 16 bits in that schema as an identifier for the \"generation\" of rollback values that we\u0027ll initialize to some value (e.g. 3) for now but can be bumped in the future to allow rollback counter format changes when needed. Imagine that for some reason Android decides to switch from timestamp-based to manually-triggered rollback bumps in a few years (not actually that unlikely considering that timestamp-based counters are going to be problematic for cases like LTS releases, which we may eventually want to add for Enterprise support). If only the lower 16 bits count (because the firmware ignores the upper 16 bits), then you may have a problem because your current timestamp-based counter value may already be pretty high, and the only numbers you can choose for whatever new scheme you want to implement would be higher than that (so e.g. if you wanted to switch to some scheme where the first two hex digits are the major Android version and the lower two represent a subversion within that, and your current major Android version is let\u0027s say 29, then the first version you\u0027d want to have in the new scheme might be 0x2901 â€” but if the previous timestamp-based counter you were using was already at 0x3456, you can\u0027t do that). By having the upper 16 bits available as a hardcoded value, we can just add +1 there (e.g. \"switch from the 3rd to the 4th generation of rollback counters\"), and then we can start in the lower 16 bits from 0 again to implement whatever clean scheme we want.\n\nAlso, one final issue is that the `kernel_version` is currently overloaded so that the upper 8 bits are also used as the rollback counter for miniOS (network-based recovery) images. We haven\u0027t quite decided if we want to keep doing that with the new OTA recovery since that\u0027s also a bit of a hack, but there are also good reasons for doing it that way, and if we do then we need some way for new normal kernel updates to be able to bump that number.\n\nI understand that just randomly adding `3 \u003c\u003c 16 | ...` in the build script somewhere may be confusing, but surely that\u0027s nothing a well-written explanatory comment couldn\u0027t solve?",
      "parentUuid": "20154704_cc587b31",
      "range": {
        "startLine": 423,
        "startChar": 20,
        "endLine": 423,
        "endChar": 59
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1368ef97_5be4f3e8",
        "filename": "firmware/2lib/2load_android_kernel.c",
        "patchSetId": 3
      },
      "lineNbr": 423,
      "author": {
        "id": 1562687
      },
      "writtenOn": "2025-11-07T08:55:13Z",
      "side": 1,
      "message": "\u003e Sorry, but I feel like the solution you\u0027re proposing is a hack to accommodate\n\u003e situation of migrated devices\n\nWe do not pass key version in Android binaries. So, in my solution I just fetch the original version from secdata to keep it unchanged. In your solution you want to create a fake value to fool the FW and as a side effect we can bump the key version in secdata unnecessary or (hopefully not) block booting if we choose a number too low. I think we have different definition of \"hack\".  \n\n\n\u003e \"that I don\u0027t want to continue carrying forever\"\n\nBut you want to carry on a solution with faking key version for all devices. For new device (not migrated devices) we don\u0027t need to write anything in upper 16 bits, so we can decide in 5 years that we drop fetching key_version for secdata for product branches and have whole 32bit value for timestamp. Am I miss something here?\n\n\u003e I think it makes sense to consider the upper 16 bits in that schema as an\n\u003e identifier for the \"generation\" of rollback values that we\u0027ll initialize\n\u003e to some value (e.g. 3) for now but can be bumped in the future to\n\u003e allow rollback counter format changes when needed.\n\nBut on the other hand you just write meaningless value to upper 16 bits. It makes no sense for a non-migrating board which will have all \u00270\u0027 in the upper half and for which we can do whatever we want.\n\n\u003e Also, one final issue is that the `kernel_version` is currently overloaded so\n\u003e that the upper 8 bits are also used as the rollback counter for\n\u003e miniOS (network-based recovery) images. \n\nOk, that can be a problem, but would it be more clean to force MiniOS for Android to follow the same schema of \u0027timestamp\u0027 based version?\n\n\n\u003e I understand that just randomly adding `3 \u003c\u003c 16 | ...` in the build script \n\u003e somewhere may be confusing, but surely solve?\n\nSure we can do that. But still someone which looks through vboot code will have the false impression that Android uses key versions, which is not true. Unless we add another comment in vboot that it is just fake value, which is pretty bad. Let\u0027s write a code which explains itself.\n\n\nAll these comments are based on the assumption that we need to support key_version in upper 16bits only for migrating boards. A new board does not need it. I hope that this is a true assumption.",
      "parentUuid": "43631cbd_f38a4fd4",
      "range": {
        "startLine": 423,
        "startChar": 20,
        "endLine": 423,
        "endChar": 59
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11a68c5e_d9b520d6",
        "filename": "firmware/2lib/include/2return_codes.h",
        "patchSetId": 3
      },
      "lineNbr": 874,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "nit: let\u0027s name this `VB2_ERROR_ANDROID_ROLLBACK_VERSION_RANGE` for consistency with the likes of `VB2_ERROR_KERNEL_PREAMBLE_VERSION_RANGE`.",
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43fe3d69_7c61a8ca",
        "filename": "firmware/avb/vboot_avb_ops.c",
        "patchSetId": 3
      },
      "lineNbr": 293,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T00:16:04Z",
      "side": 1,
      "message": "Again, should pass in the whole 32 bits.",
      "range": {
        "startLine": 293,
        "startChar": 24,
        "endLine": 293,
        "endChar": 60
      },
      "revId": "d9ac72495bfca6231b7da63511644607af475f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}