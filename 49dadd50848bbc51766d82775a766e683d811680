{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d03f13d2_5fc17eee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-06T23:26:48Z",
      "side": 1,
      "message": "LGTM for our current design, but with what I just read in that Doc this isn\u0027t going to be enough anymore. If we need to also parse the kernel command line and then do some kind of logical OR between the two MTE requests, we\u0027re going to have a problem because `vb2ex_handle_android_misc_partition()` runs before we have the vendor command line. Either we will need to push `vb2ex_handle_android_misc_partition()` deep into `prepare_vendor_ramdisks()` (to that point where we already have the header with the command line available, but before we need to know whether to load the recovery ramdisk), or we need to change this entire thing such that `vb2ex_handle_android_misc_partition()` only returns some abstract \"MTE state\" that will then be stored to kparams (maybe just as a few flags) and later translated into command line arguments at a point where we also have the whole rest of the command line available for parsing, maybe in `commandline_subst()`.\n\nI also just remembered that we still have b/408266619 pending, which I think might require us to move the misc partition check to before `avb_slot_verify()` once it gets implemented (since we need to tell it whether to verify the recovery partition or not). So maybe, honestly, this whole `extra_cmdline` approach might have always been doomed to become unsuitable at some point (sorry for not thinking about that earlier). Maybe we should think about taking this into a different direction right away?",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "606c10a2_0e9cda9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-10-07T06:48:03Z",
      "side": 1,
      "message": "\u003e 1. push vb2ex_handle_android_misc_partition() deep into prepare_vendor_ramdisks()\n\u003e 2. change this entire thing such that vb2ex_handle_android_misc_partition() only returns some abstract \"MTE state\" that will then be stored to kparams\n\nBoth of them look over-complicated to me. As there\u0027s no directly dependency between misc `bcb` and `system_space`, maybe the cleanest solution is to change `vb2ex_handle_android_misc_partition()` back to 2 separate functions (bootmode \u0026 MTE)? I assume eventually the calling order will be:\n\n- `vb2ex_get_android_bootmode`\n- `avb_slot_verify` (partitions depending on bootmode)\n- Parse MTE flag from vendor cmdline\n- `vb2ex_android_set_up_mte(vendor_mte_flag)`",
      "parentUuid": "d03f13d2_5fc17eee",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "594e854f_791d202b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 3333882
      },
      "writtenOn": "2025-10-07T08:21:57Z",
      "side": 1,
      "message": "\u003e If we need to also parse the kernel command line and then do some kind of logical OR between the two MTE requests\n\nUsually you can handle this kind of thing by just passing the same parameter to the kernel multiple times. The kernel usually handles that by picking the value from the last instance in the cmdline, so whichever option goes last is the one that is used.",
      "parentUuid": "606c10a2_0e9cda9a",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c837c00e_40bd7382",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1544412
      },
      "writtenOn": "2025-10-07T09:00:37Z",
      "side": 1,
      "message": "\u003e Usually you can handle this kind of thing by just passing the same parameter to the kernel multiple times. The kernel usually handles that by picking the value from the last instance in the cmdline, so whichever option goes last is the one that is used.\n\nIt is not about how kernel handles the cmdline. It is about the precedence when the two sources have different options. e.g,\n- cmdline: enable MTE /  misc: disable MTE\n- cmdline: disable MTE /  misc: enable MTE \n\nAccording to Jeff\u0027s [Doc], we should enable MTE for both cases.\n\n[Doc]: https://docs.google.com/document/d/1O31UJzI5WWN8VsOJl-woCSDYlocoPiYIJ5xC61KI3fo/edit?disco\u003dAAABsU49178",
      "parentUuid": "594e854f_791d202b",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d294ab1_771ca1ee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1544412
      },
      "writtenOn": "2025-10-07T09:21:17Z",
      "side": 1,
      "message": "Originally, MTE stuff is placed inside `vb2ex_handle_android_misc_partition` (vb2ex_get_android_bootmode) because we don\u0027t wan\u0027t to read and parse GPT twice[1].\nYu-Ping\u0027s suggestion looks simpler to me. Maybe it is time to consider \"don\u0027t free gptdata-\u003eprimary_header, gptdata-\u003eprimary_entries, ... etc\" inside `WriteAndFreeGptData` ?\n\nI am still uncertain about the exact point where the \"logic OR\" operation occurs, even when considering a separate `vb2ex_android_set_up_mte`. It appears that both `fastboot oem cmdline` and `commandline_append` should also be taken into this consideration.\n\n\n[1]: https://chromium-review.googlesource.com/c/chromiumos/platform/depthcharge/+/6887991/2..13/src/boot/android_mte.c#b30\n\n[WriteAndFreeGptData]: https://chromium.googlesource.com/chromiumos/platform/vboot_reference/+/refs/heads/main/firmware/lib/gpt_misc.c#231",
      "parentUuid": "c837c00e_40bd7382",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2edbe2b6_286cb561",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 3333882
      },
      "writtenOn": "2025-10-07T09:51:11Z",
      "side": 1,
      "message": "Another option you can consider is to add a new kernel parameter that freezes the value, and have the kernel ignore any options that come later on the cmdline.\n\nThat way, if you pass `kasan\u003don kasan.freeze\u003dyes kasan\u003doff`, then when evaluating `kasan\u003doff` it would see that `kasan.freeze\u003dyes` is already set and ignore the value.\n\nThis way, the logic goes in kernel instead of bootloader.",
      "parentUuid": "4d294ab1_771ca1ee",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7a5de29_81902436",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-10-07T10:28:58Z",
      "side": 1,
      "message": "With `kasan.freeze\u003dyes`, I think we may be able to get around the cmdline parsing for `bootloader.al.kasan`. In the OS build time `kasan\u003don/off` can be set directly. Then, when the bootloader wants to set `kasan\u003doff`, it instead appends `kasan.freeze\u003dyes kasan\u003doff` to the vendor cmdline, so that the bootloader cannot override the build-time `kasan\u003don`. However, I don\u0027t see how that will work for `arm64.nomte`, because we don\u0027t have an \"enable\" property `arm64.mte`.\n\n\u003e WriteAndFreeGptData\n\nI assume you\u0027re talking about the call at the end of `vb2api_load_kernel`. I guess that depends on when `vb2ex_android_set_up_mte` is called. If that happens in `vb2_load_android()` (just like it is right now), then that shouldn\u0027t be a problem, right? The GPT problem only occurs when we want to move the call to depthcharge `fill_info_gki` like CL:6887991 PS2 (meaning it doesn\u0027t need to be a `vb2ex_` function at all).",
      "parentUuid": "2edbe2b6_286cb561",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "804e89aa_f0dfcb84",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1544412
      },
      "writtenOn": "2025-10-07T11:47:24Z",
      "side": 1,
      "message": "\u003e kasan.freeze\u003dyes\n\nWhen it comes up with more cmdline options, `kasan.mode\u003dsync \u003e asymm \u003e async` and  `kasan.fault\u003dpanic \u003e panic_on_write \u003e report` (phase 2 in the Doc), adding something like `kasan.freeze\u003dyes` would introduce the complexities in the parsing of cmdline string.\n\n\u003e fill_info_gki\n\nYes, I am thinking about whether we should move all the MTE stuffs to `fill_info_gki`. Because the cmdline is finalized in that function.",
      "parentUuid": "d7a5de29_81902436",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfeadc33_c41133ac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-10-17T10:26:31Z",
      "side": 1,
      "message": "\u003e adding something like kasan.freeze\u003dyes would introduce the complexities in the parsing of cmdline string\n\nI think the reason Alice mentioned `kasan.freeze` is that, we don\u0027t need to parse the cmdline string. However, like you said, apparently that would work only for boolean properties. Therefore, as we\u0027re going to parse cmdline for other properties, `kasan.freeze` doesn\u0027t give us any benefit.\n\n\u003e Yes, I am thinking about whether we should move all the MTE stuffs to `fill_info_gki`. Because the cmdline is finalized in that function.\n\nEven if we remove the `WriteAndFreeGptData` call in `vb2api_load_kernel`, we\u0027ll still need to call `alloc_gpt` in `fill_info_gki`, right? Then we will still have the \"parsing GPT twice\" problem as in CL:6887991 PS2.\n\n\u003e It appears that both `fastboot oem cmdline` and `commandline_append` should also be taken into this consideration.\n\nSorry, I missed this comment previously. Following the [design doc](https://docs.google.com/document/d/1O31UJzI5WWN8VsOJl-woCSDYlocoPiYIJ5xC61KI3fo/edit?usp\u003dsharing), I think for Android firmware, no platform code (board.c) is supposed to set kasan properties via `commandline_append`. Also, oem cmdline will be read only in dev mode (or when VB2_GBB_FLAG_FORCE_UNLOCK_FASTBOOT is set), so that doesn\u0027t seem to be important. IMO MTE settings should be changed via `fastboot oem mte` instead of `fastboot oem cmdline`. So if people set conflicting properties in `oem mte` vs `oem cmdline`, the behavior is undefined. We may need to discuss with MTE owner @jeffxu@google.com and fastboot owner @tmichalec@google.com about this.",
      "parentUuid": "804e89aa_f0dfcb84",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc1ab945_d1ad57d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2025-10-17T14:04:58Z",
      "side": 1,
      "message": "I am okay with adding `fastboot oem mte` which just flips bits on `misc` partition. `fastboot oem cmdline` should be only used by developers, so I don\u0027t think that we should care if someone uses it to pass mte properties again. `oem cmdline` allows to add anything and FW isn\u0027t verifying it, so already it is possible to create something unexpected.",
      "parentUuid": "dfeadc33_c41133ac",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8336118b_5a55a111",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1544412
      },
      "writtenOn": "2025-10-20T04:09:48Z",
      "side": 1,
      "message": "According to\n\u003e In Android, you can change the property via adb in developer mode. Unlike in ChromeOS dev mode, the property will remain after switching back to normal mode.[1]\n\nIIUC, MTE setting can be written in `Android development mode`, the setting will remain on misc partition after switching to normal mode.\n\n\u003e fastboot oem cmdline should be only used by developers,\n\n@tmichalec@google.com If we set cmdline when the FW is switching to dev mode (ChromeOS definiton), will the cmdline remain after FW is switching to normal mode ? Will misc partition be wiped out or formatted to a initial state after switching to normal mode ?\n\n\n[1]: https://docs.google.com/document/d/1O31UJzI5WWN8VsOJl-woCSDYlocoPiYIJ5xC61KI3fo/edit?disco\u003dAAABsU49178",
      "parentUuid": "fc1ab945_d1ad57d4",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c41f2999_b70ea850",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1511343
      },
      "writtenOn": "2025-10-20T10:26:24Z",
      "side": 1,
      "message": "AFAIK `misc` isn\u0027t wiped when switching to normal mode. But in normal mode, commandline/bootconfig (that was set using `fastboot oem cmdline/bootconfig`) isn\u0027t appended to the kernel commandline (unless `GBB_FLAG_FORCE_UNLOCK_FASTBOOT` is set). When you switch back to dev mode/set fastboot GBB flag, then bootloader will use again whatever was set on the `misc` partition before.",
      "parentUuid": "8336118b_5a55a111",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4444694_de85220e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1544412
      },
      "writtenOn": "2025-10-20T10:26:29Z",
      "side": 1,
      "message": "It looks like the [cmdline] saved in misc partition is ignored in normal mode. I will simplify MTE request handling by following order in `side vb2_load_android`.\n\n```\nvb2_load_android () {\n    vb2ex_get_android_bootmode\n    avb_slot_verify (partitions depending on bootmode)\n    rearrange_partitions(params) // read kernel cmdline from vendor\n\n    // vb2ex_android_set_up_mte()\n    // 1. read memtag_mode from misc\n    // 2. Parse params-\u003ereal_cmdline_ptr and do logic OR with memtag_mode\n    // 3. Update params-\u003ereal_cmdline_ptr accordingly.\n    vb2ex_android_set_up_mte(gpt, params)\n}\n```\nIn the development mode (either Android or ChromeOS definition), the developer should be responsible for the order of cmdline coming from `fastboot oem cmdline` and `fastboot oem mte`.\n\n@jwerner@chromium.org @yupingso@chromium.org what do you think ?\n\n[cmdline]: https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/platform/depthcharge/src/vboot/boot_info.c;l\u003d236",
      "parentUuid": "8336118b_5a55a111",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d688ede5_5cbb7324",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1353551
      },
      "writtenOn": "2025-10-21T07:48:41Z",
      "side": 1,
      "message": "Sounds good to me.",
      "parentUuid": "c4444694_de85220e",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "910987f4_e1f34d31",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1544412
      },
      "writtenOn": "2025-10-22T10:35:27Z",
      "side": 1,
      "message": "Please review CL:6887991 and this patch.",
      "parentUuid": "d688ede5_5cbb7324",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aba38ed0_bf7617f6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-10-25T01:20:48Z",
      "side": 1,
      "message": "Apologies for not keeping up with this discussion in time. However, I\u0027m not a fan of the current outcome. In order to follow the latest approach discussed on Jeff\u0027s doc (with \"fake\" command line arguments parsed by depthcharge that then get combined with the misc partition state into real arguments), and to keep details about the (platform-specific) MTE stuff out of vboot, I would prefer different approach:\n\nWe should keep the concept of `vb2ex_handle_android_misc_partition()`, even if it may later need to be moved before `avb_slot_verify()`. However, we can\u0027t pass the MTE state back out as a command line argument string because the final command line arguments are not decided yet (we need to combine it with the \"fake\" arguments from the actual command line first, and I believe the cleanest point to do that would be after `commandline_subst()` when the full, final command line with all `commandline_append()` bits is assembled). So `vb2ex_handle_android_misc_partition()` no longer needs the `extra_commandline` output parameter, and should instead store the MTE state requested by the misc partition in a different way (e.g. just as the `memtag_mode` integer bitfield that was read from the misc partition) for later until we also have the other pieces at hand and can combine them. I believe it should be fine to just use a static global variable in depthcharge for that, as long as we make sure that that variable is overwritten on every call to `vb2ex_handle_android_misc_partition()` (because we know that function will be called again for every boot attempt).\n\nThen in `arch/arm/fit.c:update_chosen()`, right after the final command line is assembled, we should call into a different function in `android_mte.c` and pass it the `cmd_line_buf` and size. That function will then parse the \"fake\" argument (e.g. `bl.mtectl\u003d` or however we\u0027re calling it) out of that command line, and combine it with the `memtag_mode` stored in the global variable into the final requested MTE state. Then it will just append the arguments that result from that at the end of `cmd_line_buf` (which is going to have free space left at that point so we don\u0027t need to deal with string allocation or copying).\n\nDoes that seem like a reasonable approach?",
      "parentUuid": "910987f4_e1f34d31",
      "revId": "49dadd50848bbc51766d82775a766e683d811680",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}