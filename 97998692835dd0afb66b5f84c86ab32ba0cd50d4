{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f3ad1907_27cd0645",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1542640
      },
      "writtenOn": "2023-12-07T20:09:14Z",
      "side": 1,
      "message": "Thank you Julius for all you valuable comments. I am very busy these days so I cannot look at them in details but Monir is looking in them with my support.\n\nI hope to have more time next week to help on those patches again.",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "caa17498_66f8ac8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-07T20:56:08Z",
      "side": 1,
      "message": "I\u0027ll be out most of next week unfortunately, I\u0027ll probably only work on Monday and Friday. I\u0027ll try to prioritize this review with the time I have.",
      "parentUuid": "f3ad1907_27cd0645",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f67b149_0243fbec",
        "filename": "Makefile",
        "patchSetId": 11
      },
      "lineNbr": 419,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "The name for this should say \"RSA\" somewhere, e.g. `X86_RSA_SSE2`.",
      "range": {
        "startLine": 419,
        "startChar": 24,
        "endLine": 419,
        "endChar": 38
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05b10915_429c1202",
        "filename": "Makefile",
        "patchSetId": 11
      },
      "lineNbr": 431,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "IIRC for 2sha256_x86.c we decided to reimplement the necessary intrinsics in the file directly to keep the firmware build hermetic, so we should do the same here as well.\n\nShould you maybe also add an `-mno-avx` here to make sure the compiler doesn\u0027t go further than intended with this?",
      "range": {
        "startLine": 431,
        "startChar": 51,
        "endLine": 431,
        "endChar": 72
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77b4a4b7_22bad0a8",
        "filename": "Makefile",
        "patchSetId": 11
      },
      "lineNbr": 1151,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "We should have special tests similar to here to cover this RSA implementation. Maybe you could build a second version of the `vb20_verify_fw` test that links the hwcrypto implementation and then have `vb2_firmware_tests.sh` run that in addition to the default one with the same arguments (that way we would also have the workbuffer watermark numbers for this version in the test output, which would be good).",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ff418d8_44025a8d",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 29,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "Normally I like these macros, but since we only need it in a single spot here it\u0027s probably easier to just hardcode the masking there.",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42716495_b7244cf9",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 52,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-08T01:17:00Z",
      "side": 1,
      "message": "Can this be optimized with `_subborrow_u32()`?",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efa50305_d94c4564",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 52,
      "author": {
        "id": 3062142
      },
      "writtenOn": "2023-12-11T22:58:48Z",
      "side": 1,
      "message": "We have implemented using _subborrow_u32() according to your suggestion and tested Vboot RSA signature verification with Linux user-space program (performance of user-space program is linear to the boot time as we experimented before). Unfortunately, this implementation increases the performance overhead by around 12%, which is a significant degradation. Again, _subborrow_u32() is not available in SSE2, it requires AVX (reference given below).\n\nhttps://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text\u003d_subborrow_u32\u0026ig_expand\u003d305,2886,2886,2886,4602,1338,1338,1338,6665,6665",
      "parentUuid": "42716495_b7244cf9",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35c8590a_795db342",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 104,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-07T01:25:01Z",
      "side": 1,
      "message": "Just want to double-check, are there any integer multiply-and-add instructions in SSE that would allow us to combine these two steps into a single one? I found that Arm has a UMLAL instruction which I believe would work for that, but it seems that Intel has no equivalent?",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c686d48_e77e2835",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 110,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "Is there a notable time difference if you just regenerate `b_modulus[i]` from scratch inside this loop, rather than memoize it beforehand? I mean this is basically the difference between loading one full 128-bit SSE2 register from memory vs. loading two 32-bit locations (`b[i]` and `key-\u003en[i]`) into an SSE2 register from memory. I\u0027m wondering if we can save some space by avoiding the `b_modulus` array.",
      "range": {
        "startLine": 110,
        "startChar": 28,
        "endLine": 110,
        "endChar": 40
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83774743_b94f7254",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 110,
      "author": {
        "id": 1542640
      },
      "writtenOn": "2023-12-08T00:24:32Z",
      "side": 1,
      "message": "I just did the experiments: Removing the array and using `_mm_set_epi32(0, b[i], 0, key-\u003en[i])` instead of per-computing increases the modpow() total time by about 4%.",
      "parentUuid": "4c686d48_e77e2835",
      "range": {
        "startLine": 110,
        "startChar": 28,
        "endLine": 110,
        "endChar": 40
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25df3480_616a671a",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 110,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-08T00:57:19Z",
      "side": 1,
      "message": "That sounds like it\u0027s probably within the margin of measurement error and could be acceptable?\n\nI think I would prefer for simplicity if we can fit within the existing 12KB workbuf size (at least for the common 11-7-4 algorithm case... 11-11-11 isn\u0027t really used in practice, so as long as that would safely fall back to the old code by implementing this as a hwcrypto backend, I think we don\u0027t need to care about it). With all the suggestions I added (eliminate `b_modulus`, cut `de` in half and reuse `inout` buffer), I think that might just barely be possible. But if it isn\u0027t and we need to make some architecture-specific adjustment either way, then I guess the amount for x86 doesn\u0027t really matter so we could leave it at whatever is the fastest.",
      "parentUuid": "83774743_b94f7254",
      "range": {
        "startLine": 110,
        "startChar": 28,
        "endLine": 110,
        "endChar": 40
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fb540a4_a5975fd5",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 110,
      "author": {
        "id": 1542640
      },
      "writtenOn": "2023-12-08T18:55:56Z",
      "side": 1,
      "message": "\u003e That sounds like it\u0027s probably within the margin of measurement error and could be acceptable?\n\nNo with the methodology I use the precision margin is 0.4% so 4% is a significant degradation.",
      "parentUuid": "25df3480_616a671a",
      "range": {
        "startLine": 110,
        "startChar": 28,
        "endLine": 110,
        "endChar": 40
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70a8a6b5_e84122db",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 114,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "Could we use `_mm_mask_compressstoreu_epi32` (or a similar instruction if you know a better one) to store the two 32-bit integers we care about here in a 64-bit array in memory, and then later re-extract them from there with `_mm_maskz_expandloadu_epi32` where we need them? I\u0027m trying to find more ways to cut down on the workbuf space demand.",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9ac7ea9_ca85d0b9",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 134,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "Since we know this is only targeting x86 to begin with we can probably just use `__builtin_bswap32()` here. (In fact, I\u0027m not sure why we didn\u0027t just do that everywhere to begin with...)",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43fefae8_2fc518ed",
        "filename": "firmware/2lib/2modpow_sse2.c",
        "patchSetId": 11
      },
      "lineNbr": 160,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-08T00:57:19Z",
      "side": 1,
      "message": "Actually, was there ever a good reason why `inout` is copied into `a` instead of just swapping the bytes in-place? That shouldn\u0027t be hard, right? That could save us another `4*arrsize` bytes...",
      "range": {
        "startLine": 160,
        "startChar": 28,
        "endLine": 160,
        "endChar": 33
      },
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31c81088_1bb0ce40",
        "filename": "firmware/2lib/include/2rsa_private.h",
        "patchSetId": 11
      },
      "lineNbr": 17,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2023-12-06T01:56:45Z",
      "side": 1,
      "message": "Let\u0027s make this a macro that takes `key_bytes` as an argument, that way you can make this `((s * 11) + 8)` instead of `(s * 12)` (or better `((s * 7) + 8)` if you can avoid the `b_modulus` array).",
      "revId": "97998692835dd0afb66b5f84c86ab32ba0cd50d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}