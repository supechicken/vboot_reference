{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "43ff8736_86b19478",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2024-12-30T17:55:07Z",
      "side": 1,
      "message": "Can you please link the patch that would actually use this flag to give an idea what kinds of output you want to guard with it?\n\nIn general, I would caution not to hide a ton of super verbose debugging output behind a runtime flag, because even if the output is disabled the compiler is still adding all of those strings to the binary. You\u0027re basically still eating all of the cost of adding extra debugging output so there is little reason to not have it enabled and logged to CBMEM console all the time. I would normally suggest to just add as much debugging output with normal printk as you feel might be needed on production builds (and if that feels too spammy you can mark it as BIOS_SPEW and people can reduce the loglevel if it annoys them, that\u0027s what that\u0027s for), and any extra output that adds a large amount of new strings which we don\u0027t want to burden the production build with should be hidden behind a hard Kconfig. I don\u0027t think there\u0027s really a good use case for output that\u0027s compiled in but never active by default.\n\nIn essence, I think you\u0027re basically just reinventing the loglevel here, and we should just use the actual loglevel for that instead (and maybe adjust the way we use it if it doesn\u0027t suit your needs right now).",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "715cbfe1_d3c687e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2024-12-31T02:05:16Z",
      "side": 1,
      "message": "\u003e Can you please link the patch that would actually use this flag to give an idea what kinds of output you want to guard with it?\n\u003e \n\u003e In general, I would caution not to hide a ton of super verbose debugging output behind a runtime flag, because even if the output is disabled the compiler is still adding all of those strings to the binary. You\u0027re basically still eating all of the cost of adding extra debugging output so there is little reason to not have it enabled and logged to CBMEM console all the time. I would normally suggest to just add as much debugging output with normal printk as you feel might be needed on production builds (and if that feels too spammy you can mark it as BIOS_SPEW and people can reduce the loglevel if it annoys them, that\u0027s what that\u0027s for), and any extra output that adds a large amount of new strings which we don\u0027t want to burden the production build with should be hidden behind a hard Kconfig. I don\u0027t think there\u0027s really a good use case for output that\u0027s compiled in but never active by default.\n\u003e \n\u003e In essence, I think you\u0027re basically just reinventing the loglevel here, and we should just use the actual loglevel for that instead (and maybe adjust the way we use it if it doesn\u0027t suit your needs right now).\n\n\nCould you please hold off on reviewing this until I\u0027ve had a chance to update the design doc? If you\u0027re still keen to understand what this CL is aiming for, please take a look at https://chromium-review.googlesource.com/q/topic:%22unified_ap_debug%22\n\nHere is high level summary and I will share the design doc later\n\n\n# Problem Statement\n\nGoogle non-firmware team, SoC Partners and/or OxMs encounter three main problems when debugging silicon firmware:\n - Need for custom images: Partners must create special debug builds to enable verbose logging, requiring source code access and build expertise.\n - Replication challenges: Debugging and replicating issues becomes difficult as the custom debug build may not accurately represent the original failing firmware version.\n - Limited accessibility: Hardware and integration teams without firmware development expertise are hindered from debugging silicon-related issues.\n\n# Proposed Solution\nTo address these problems, we propose a new approach to AP firmware image creation and debug logging:\n- Dual Image Approach: Continue providing two AP firmware images:\n   * image-$BOARD.bin: Production image with release builds of both coreboot and silicon firmware (optimized for performance).\n   * image-$BOARD.serial.bin: Enhanced image containing:\n      - Debug build of coreboot.\n      - Debug build of silicon firmware.\n\n- Dynamic Debug Control: Introduce a mechanism to dynamically control the verbosity of silicon firmware debug logs. This will be achieved through a flag in the Google Binary Block (GBB).\n\n- coreboot Integration: Leverage coreboot\u0027s capability to handle and route silicon firmware debug messages. coreboot will:\n    * Read the GBB flag during initialization.\n    * Based on the flag\u0027s value, either enable or suppress the output of debug messages from the silicon firmware.",
      "parentUuid": "43ff8736_86b19478",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78c80d1c_193df4d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-01-03T16:25:25Z",
      "side": 1,
      "message": "Sure, I can wait. I do feel like my concerns may still apply to what you sketched there, though. \"Dynamic Debug Control\" is basically the point of having a log level already, we don\u0027t need to reinvent it. The `cbmem` utility already has a `--loglevel` option to filter the output, and we\u0027ve had plans for adding a serial-console-specific loglevel control as a CBFS file before that could be revived (CB:45208). You might want to look into those options when writing your design.\n\n(Also, the problem about debug print strings increasing binary size remains, so for the really spammy stuff I\u0027d recommend to still keep them behind a Kconfig that\u0027s only enabled for the .serial.bin build.)",
      "parentUuid": "715cbfe1_d3c687e7",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6bd99ba_226811e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-01-04T01:41:35Z",
      "side": 1,
      "message": "\u003e Sure, I can wait. I do feel like my concerns may still apply to what you sketched there, though. \"Dynamic Debug Control\" is basically the point of having a log level already, we don\u0027t need to reinvent it. The `cbmem` utility already has a `--loglevel` option to filter the output, and we\u0027ve had plans for adding a serial-console-specific loglevel control as a CBFS file before that could be revived (CB:45208). You might want to look into those options when writing your design.\n\u003e \n\u003e (Also, the problem about debug print strings increasing binary size remains, so for the really spammy stuff I\u0027d recommend to still keep them behind a Kconfig that\u0027s only enabled for the .serial.bin build.)\n\n\nNot sure if we are in same page here. Let me share the design doc with you first to start with go/dynamic_ap_firmware\n\nThe idea is to keep debug build if FSP/silicon FW in all serial bin image and then use GBB to control the flow.",
      "parentUuid": "78c80d1c_193df4d2",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "036fb05e_eaa550aa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-01-06T16:21:53Z",
      "side": 1,
      "message": "Okay, thanks, I think I understand better now. So if I understand your document right:\n\n* You don\u0027t want to change anything for production (image.bin) images.\n\n* You don\u0027t want to change anything for logs that are printed by coreboot (this is only about FSP logging)\n\n* All you want to do is essentially to always link the debug FSP build into image.serial.bin, but then have a runtime control for the FSP loglevel?\n\nThat all makes sense and seems like a good idea to me, however, I still think a GBB flag is probably not the best backend for this runtime control. GBB flags are tied into vboot and really just meant to control vboot and boot flow related things (this hasn\u0027t always been 100% followed in practice but was the general idea). \n\nFor general coreboot stuff that has nothing to do with vboot, the usual way to encode easily changeable options in the flash image is with CBFS files just containing an integer. You can then use e.g. `cbfstool image.serial.bin add-int -i 5 -n fsp_pcd_debug_level` to create a file that stores the FSP loglevel and then just read it and pass it to the UPD from coreboot. You could even have two files for the two separate log levels you have there (PCD and MRC). I think that may be a better way to implement this?",
      "parentUuid": "d6bd99ba_226811e4",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89981a52_e7475aa9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-01-08T10:20:20Z",
      "side": 1,
      "message": "\u003e Okay, thanks, I think I understand better now. So if I understand your document right:\n\u003e \n\u003e * You don\u0027t want to change anything for production (image.bin) images.\n\u003e \n\u003e * You don\u0027t want to change anything for logs that are printed by coreboot (this is only about FSP logging)\n\u003e \n\u003e * All you want to do is essentially to always link the debug FSP build into image.serial.bin, but then have a runtime control for the FSP loglevel?\n\u003e \n\u003e That all makes sense and seems like a good idea to me, however, I still think a GBB flag is probably not the best backend for this runtime control. GBB flags are tied into vboot and really just meant to control vboot and boot flow related things (this hasn\u0027t always been 100% followed in practice but was the general idea). \n\u003e \n\u003e For general coreboot stuff that has nothing to do with vboot, the usual way to encode easily changeable options in the flash image is with CBFS files just containing an integer. You can then use e.g. `cbfstool image.serial.bin add-int -i 5 -n fsp_pcd_debug_level` to create a file that stores the FSP loglevel and then just read it and pass it to the UPD from coreboot. You could even have two files for the two separate log levels you have there (PCD and MRC). I think that may be a better way to implement this?\n\nthanks for the suggestion @julius, I really like this idea and eventually something also coming up during the doc review as well. I will mark this resolved and update the doc to reflect this design choice",
      "parentUuid": "036fb05e_eaa550aa",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69319699_2ccb65cd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-01-08T11:44:58Z",
      "side": 1,
      "message": "\u003e \u003e Okay, thanks, I think I understand better now. So if I understand your document right:\n\u003e \u003e \n\u003e \u003e * You don\u0027t want to change anything for production (image.bin) images.\n\u003e \u003e \n\u003e \u003e * You don\u0027t want to change anything for logs that are printed by coreboot (this is only about FSP logging)\n\u003e \u003e \n\u003e \u003e * All you want to do is essentially to always link the debug FSP build into image.serial.bin, but then have a runtime control for the FSP loglevel?\n\u003e \u003e \n\u003e \u003e That all makes sense and seems like a good idea to me, however, I still think a GBB flag is probably not the best backend for this runtime control. GBB flags are tied into vboot and really just meant to control vboot and boot flow related things (this hasn\u0027t always been 100% followed in practice but was the general idea). \n\u003e \u003e \n\u003e \u003e For general coreboot stuff that has nothing to do with vboot, the usual way to encode easily changeable options in the flash image is with CBFS files just containing an integer. You can then use e.g. `cbfstool image.serial.bin add-int -i 5 -n fsp_pcd_debug_level` to create a file that stores the FSP loglevel and then just read it and pass it to the UPD from coreboot. You could even have two files for the two separate log levels you have there (PCD and MRC). I think that may be a better way to implement this?\n\u003e \n\u003e thanks for the suggestion @julius, I really like this idea and eventually something also coming up during the doc review as well. I will mark this resolved and update the doc to reflect this design choice\n\n\nbtw, looks like there is one catch that we might need to execute `cbfstool image.serial.bin add-int -i 5 -n fsp_pcd_debug_level` for all 3 copies of the FW like RP and RW-A/B",
      "parentUuid": "89981a52_e7475aa9",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd872176_e1b960b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-01-08T12:03:42Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Okay, thanks, I think I understand better now. So if I understand your document right:\n\u003e \u003e \u003e \n\u003e \u003e \u003e * You don\u0027t want to change anything for production (image.bin) images.\n\u003e \u003e \u003e \n\u003e \u003e \u003e * You don\u0027t want to change anything for logs that are printed by coreboot (this is only about FSP logging)\n\u003e \u003e \u003e \n\u003e \u003e \u003e * All you want to do is essentially to always link the debug FSP build into image.serial.bin, but then have a runtime control for the FSP loglevel?\n\u003e \u003e \u003e \n\u003e \u003e \u003e That all makes sense and seems like a good idea to me, however, I still think a GBB flag is probably not the best backend for this runtime control. GBB flags are tied into vboot and really just meant to control vboot and boot flow related things (this hasn\u0027t always been 100% followed in practice but was the general idea). \n\u003e \u003e \u003e \n\u003e \u003e \u003e For general coreboot stuff that has nothing to do with vboot, the usual way to encode easily changeable options in the flash image is with CBFS files just containing an integer. You can then use e.g. `cbfstool image.serial.bin add-int -i 5 -n fsp_pcd_debug_level` to create a file that stores the FSP loglevel and then just read it and pass it to the UPD from coreboot. You could even have two files for the two separate log levels you have there (PCD and MRC). I think that may be a better way to implement this?\n\u003e \u003e \n\u003e \u003e thanks for the suggestion @julius, I really like this idea and eventually something also coming up during the doc review as well. I will mark this resolved and update the doc to reflect this design choice\n\u003e \n\u003e \n\u003e btw, looks like there is one catch that we might need to execute `cbfstool image.serial.bin add-int -i 5 -n fsp_pcd_debug_level` for all 3 copies of the FW like RP and RW-A/B\n\ntypo, RO ( and not RP)",
      "parentUuid": "69319699_2ccb65cd",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dcd50cc5_7865e687",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-01-08T17:01:22Z",
      "side": 1,
      "message": "That\u0027s one way to do it. You could also decide to just always access the file in RO (via `cbfs_ro_map()`). Considering that this is supposed to just be a tool for people who already have full flash access anyway, that\u0027s probably the more convenient option.",
      "parentUuid": "bd872176_e1b960b3",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52993d02_3778e598",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1532003
      },
      "writtenOn": "2025-01-08T17:05:28Z",
      "side": 1,
      "message": "\u003e That\u0027s one way to do it. You could also decide to just always access the file in RO (via `cbfs_ro_map()`). Considering that this is supposed to just be a tool for people who already have full flash access anyway, that\u0027s probably the more convenient option.\n\nI think we should integrate this into coreboot stages like romstage and ramstage. These stages try to control the log level of SoC firmware blobs, so we need these files outside of RO as well. That is, these copies should also be present inside RW-A/B. We might need to allow for utmost configurability, where partners or users are not limited with their resources while enabling verbose mode for the SoC firmware log during debugging. What do you think? The first approach, which keeps the file in all copies, seems like the best option here.",
      "parentUuid": "dcd50cc5_7865e687",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03571290_5edbccc0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002133
      },
      "writtenOn": "2025-01-08T17:12:59Z",
      "side": 1,
      "message": "Yes, I know that this will be read from romstage/ramstage, but I don\u0027t really understand your concern. An RW romstage/ramstage can access a file in RO CBFS via the `cbfs_ro_map()` API no problem, that\u0027s what that\u0027s there for. coreboot is already doing that in other cases where duplicating a file across the 3 sections doesn\u0027t make sense (e.g. for the `cmos.layout` file when using OPTION_TABLE). This is essentially also how GBB flags work, we only have one instance of GBB flags in the RO flash, not a different set of flags for each slot, that would just be confusing and is not really needed.",
      "parentUuid": "52993d02_3778e598",
      "revId": "cb78bfc0cd9083d5a0c9df291f3281501880892a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}